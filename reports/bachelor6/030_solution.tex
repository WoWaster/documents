% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}

Изначально научным руководителем были зафиксированы следующие требования к тестам:
\begin{itemize}
    \item Тесты должны быть открытыми.
    \item Тесты должны быть property-based.
    \item Задачи должны сдаваться с помощью PR.
    \item Имена и сигнатуры требуемых функций и классов известны заранее.
    \item Архитектуру проекта и связь между модулями студенты определяют сами.
\end{itemize}

% \subsection{Описание задач}

% Задачи в курсе разбиты на 3 блока:
% \begin{enumerate}
%     \item Регулярные языки
%     \item Контекстно-свободные запросы
%     \item Синтаксис и семантика
% \end{enumerate}

% \subsubsection{Регулярные языки}

% Данный блок содержит

% \subsubsection{Контекстно-свободные запросы}
% Аналогично

% \subsubsection{Синтаксис и семантика}
% Этот блок менее обязательный и задачки в нём объёмнее

\subsection{Инфраструктура тестирования}
\label{subsec:infra}

\note{\enquote{Не хватает какой-то диаграмки типа модулей и прочего. Чтобы показать, какие глобально части есть, что было сделано, что закрыто, что открыто, какие зависимости.} Пока не понимаю как это нарисовать}

\begin{listing}[b]
    \caption{Код отвечающий за запуск или пропуск теста, в зависимости от наличия или отсутствия решения задачи}
    \inputminted[linenos, breaklines, frame=single, fontsize = \small]{python3}{figures/minimal_example.py}
    \label{listing:skip}
\end{listing}

Основная проблема при написании тестов к курсу~--- необходимость запуска тестов только для реализованных студентом заданий.

Одним из самых простых решений является создание отдельного репозитория для каждой задачи.
Такой подход крайне неудобен для нашего курса, так как создавать 12 репозиториев для заданий, которые зависят друг от друга, а затем добавлять в каждый проверяющего, будет слишком неудобно.

Далее можно просто запускать только необходимые тесты, например указывая их как параметр для фреймворка тестирования.
Здесь не требуется создавать много репозиториев, и после выполнения каждой задачи студенту достаточно будет включить необходимые тесты.
Но кроме этого потребуется исправить пути импорта тестируемых модулей.

Наш подход основывается на том, что пути импорта исправлять нужно всегда и это может служить минимальным требованием для запуска тестов.
\python{}~--- интерпретируемый язык, поэтому поиск необходимых модулей происходит во время исполнения.
Это позволяет прямо во время исполнения узнать существует ли решение нужной задачи, и в зависимости от этого запустить или пропустить тесты.
Достаточно попробовать импортировать нужные объекты, и, в случае получения \texttt{ImportError}, выставить флаг пропуска всех тестов в модуле~(см. листинг \ref{listing:skip}).

\subsection{Проверка автоматических тестов}
\label{subsec:slns}

Написанием самих тестов занимался мой товарищ, Ефим Кубышкин.
Моей задачей была проверка тестов, путём реализации задач из курса.

Задачи в курсе разделены на три крупных блока.
\begin{enumerate}
    \item Регулярные языки.
    \item Контекстно-свободные запросы.
    \item Синтаксис и семантика.
\end{enumerate}
И обычно предполагают либо создание обертки над библиотечными функциями, либо аккуратную реализацию алгоритма.

В первом блоке предлагается реализовать два алгоритма регулярных запросов к графу: тензорный алгоритм и алгоритм на основе поиска в ширину \note{У этого есть название лучше?}.
Во втором блоке необходимо реализовать четыре алгоритма контекстно-свободных запросов: алгоритм Хеллингса, матричный алгоритм Рустама Азимова, тензорный алгоритм, алгоритм на основе GLL.
Третий блок предполагает работу с модельным языком запросом графов: написание парсера с использованием \textsc{ANTLR}, реализацию вывода типов, а затем интерпретатора.

Наиболее содержательным и требующим усилий оказался третий блок.
\note{А реально надо какие-нибудь слова про то, что там вывод типов не самый очевидный или ну нафиг?}

Реализованные задачи выкладывались в приватный репозиторий, в котором был настроен CI, таким образом, чтобы проверять тесты из \texttt{main} ветки основного репозитория.

\subsection{Обновление используемых инструментов}
\label{subsec:housekeeping}

При реализации одного из заданий появилась необходимость в использовании транзитивного замыкания графа.
Однако при запуске выяснилось, что установленная версия \networkx{} не поддерживает транзитивное замыкание для класса \texttt{MultiDiGraph}.
Дальнейшее исследование показало, что не смотря на указание более свежей версии \networkx{}, \pip{}~--- стандартный пакетный менеджер для \python{}~--- выбирал более старую версию, так как её требовал пакет \cfpqdata{}.

В течение семестра для решения этой проблемы был создан Pull Request в библиотеку \cfpqdata{} с обновлением всех её зависимостей.
Поддержкой библиотеки занимается старший преподаватель кафедры ИАС Азимов Рустам Шухратуллович, поэтому Pull Request был принят быстро, после чего была опубликована новая версия библиотеки.

Дабы избежать подобной проблемы в будущем было решено перейти на использование \poetry{} в качестве менеджера пакетов.
\poetry{} использует собственный продвинутый решатель зависимостей, который сообщит об ошибке в подобной ситуации.

\note{Не понимаю тоже надо ли сюда ещё что-то}
% \note{Сюда про проблемы с хешем + dependabot + ещё что-то?}
