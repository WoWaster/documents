% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}

Изначально научным руководителем были зафиксированы следующие требования к тестам:
\begin{itemize}
    \item Тесты должны быть открытыми.
    \item Тесты должны быть property-based.
    \item Задачи должны сдаваться с помощью PR.
    \item Имена и сигнатуры требуемых функций и классов известны заранее.
    \item Архитектуру проекта и связь между модулями студенты определяют сами.
\end{itemize}

\subsection{Инфраструктура тестирования}
\label{subsec:infra}

\note{\enquote{Не хватает какой-то диаграмки типа модулей и прочего. Чтобы показать, какие глобально части есть, что было сделано, что закрыто, что открыто, какие зависимости.} Пока не понимаю как это нарисовать}

\begin{listing}[b]
    \caption{Код отвечающий за запуск или пропуск теста, в зависимости от наличия или отсутствия решения задачи}
    \inputminted[linenos, breaklines, frame=single, fontsize = \small]{python3}{figures/minimal_example.py}
    \label{listing:skip}
\end{listing}

Основная проблема при написании тестов к курсу~--- необходимость запуска тестов только для реализованных студентом заданий.

Одним из самых простых решений является создание отдельного репозитория для каждой задачи.
Такой подход крайне неудобен для нашего курса, так как создавать 12 репозиториев для заданий, которые зависят друг от друга, а затем добавлять в каждый проверяющего, будет слишком неудобно.

В качестве альтернативного решения можно запускать только необходимые тесты, например указывая их как параметр для фреймворка тестирования.
Здесь не требуется создавать много репозиториев, и после выполнения каждой задачи студенту достаточно будет включить необходимые тесты.
Но кроме этого потребуется исправить пути импорта тестируемых модулей.

Наш подход основывается на том, что пути импорта исправлять нужно всегда и это может служить минимальным требованием для запуска тестов.
\python{}~--- интерпретируемый язык, поэтому поиск необходимых модулей происходит во время исполнения.
Это позволяет прямо во время исполнения узнать существует ли решение нужной задачи, и в зависимости от этого запустить или пропустить тесты.
Достаточно попробовать импортировать нужные объекты, и, в случае получения \texttt{ImportError}, выставить флаг пропуска всех тестов в модуле~(см. листинг \ref{listing:skip}).

\subsection{Проверка автоматических тестов}
\label{subsec:slns}

Написанием самих тестов занимался мой товарищ, Ефим Кубышкин.
Моей задачей была проверка тестов, путём реализации задач из курса.

Задачи в курсе разделены на три крупных блока.
\begin{enumerate}
    \item Регулярные языки.
    \item Контекстно-свободные запросы.
    \item Синтаксис и семантика.
\end{enumerate}
И обычно предполагают либо создание обертки над библиотечными функциями, либо самостоятельную реализацию алгоритма.

В первом блоке предлагается реализовать два алгоритма регулярных запросов к графу: тензорный алгоритм и алгоритм на основе поиска в ширину.
Во втором блоке необходимо реализовать четыре алгоритма исполнения контекстно-свободных запросов: алгоритм Хеллингса, матричный алгоритм Рустама Азимова, тензорный алгоритм, алгоритм на основе GLL.
Третий блок предполагает работу с модельным языком запросов к графам: написание парсера с использованием \antlr{}, реализацию вывода типов, а затем интерпретатора.

Задача №1 вводная, в ней необходимо создать fork, написать две функции и тесты к ним для знакомства с библиотеками, а также настроить CI для запуска тестов.
Автотесты к ней не были реализованы.

В задаче №2 необходимо научиться преобразовывать регулярное выражение в ДКА и граф в формате \networkx{} в НКА, используя библиотеку \pyformlang{}.
Обе функции по сути являются обертками на цепочками функций из библиотеки.

В задаче №3 требовалось реализовать класс, описывающий конечный автомат в формате разреженной матрицы из \scipy{}, а затем тензорный алгоритм выполнения регулярных запросов к графам~\cite{shemetovaOneAlgorithmEvaluate2021}.

В задаче №4 необходимо было реализовать алгоритм выполнения регулярных запросов к графу на основе обхода в ширину~\cite{elekesGraphBLASSolutionSIGMOD2020}.

Задача №5 подразумевает постановку экспериментов, поэтому не тестировалась.

В задаче №6 необходимо было реализовать функцию преобразования контекстно-свободной грамматики в ослабленную нормальную форму Хомского (ОНФХ) и алгоритм исполнения контекстно-свободных запросов Хеллингса~\cite{hellingsConjunctiveContextFreePath2014}.

В задаче №7 требовалось реализовать матричный алгоритм исполнения контекстно-свободных запросов Рустама Азимова~\cite{azimovContextfreePathQuerying2018}.

В задаче №8 необходимо было сначала научиться работать с Recursive State Machine~(RSM) из \pyformlang{} путём реализации функций конвертации различных представлений КС грамматик в RSM.
А затем реализовать тензорный алгоритм исполнения контекстно-свободных запросов~\cite{orachevContextFreePathQuerying2020, shemetovaOneAlgorithmEvaluate2021}.

В задаче №9 требовалось реализовать алгоритм исполнения контекстно-свободных запросов на основе Generalized LL~\cite{abzalovGLLbasedContextFreePath2023}.

Задача №10 подразумевает постановку экспериментов, поэтому не тестировалась.

В задаче №11 необходимо было написать парсер модельного языка запросов к графам с использованием \antlr{}, а так же функцию подсчёта количества узлов и функцию преобразования дерева разбора в текст программы.

В задаче №12 требовалось реализовать механизм вывода типов и интерпретатор для языка из задания №11.
Эта задача достаточно сильно отличается от предыдущих, так как алгоритм вывода типов требуется придумать самому.
В модельном ЯП не присутствует полиморфизм, что облегчает задачу.
Однако присутствует возможность ссылаться на ещё не объявленные переменные, так как большая часть объявлений~--- правила КС грамматики в регулярной форме (см. листинг \ref{listing:example}).
В таком случае необходимо отдельно строить граф зависимостей объявлений друг от друга.

\begin{listing}
    \caption{Пример объявления грамматики, задающей язык $a^n b^n$, в модельном языке}
    \begin{minted}[linenos, breaklines, frame=single, fontsize = \small]{rust}
        let a = ("a" . b) | "a" ^ [0..0]
        let b = a . "b"
        \end{minted}
    \label{listing:example}
\end{listing}

Реализованные задачи выкладывались в приватный репозиторий.
В нём был настроен CI, который запускал автотесты из \texttt{main} ветки основного репозитория на эталонных решениях.

\subsection{Обновление используемых инструментов}
\label{subsec:housekeeping}

При реализации одного из заданий появилась необходимость в использовании транзитивного замыкания графа.
Однако при запуске выяснилось, что установленная версия \networkx{} не поддерживает транзитивное замыкание для класса \texttt{MultiDiGraph}.
Дальнейшее исследование показало, что не смотря на указание более свежей версии \networkx{}, \pip{}~--- стандартный пакетный менеджер для \python{}~--- выбирал более старую версию, так как её требовал пакет \cfpqdata{}.

В течение семестра для решения этой проблемы был создан Pull Request в библиотеку \cfpqdata{} с обновлением всех её зависимостей.
Поддержкой библиотеки занимается старший преподаватель кафедры ИАС Азимов Рустам Шухратуллович, поэтому Pull Request был принят быстро, после чего была опубликована новая версия библиотеки.

Дабы избежать подобной проблемы в будущем было решено перейти на использование \poetry{} в качестве менеджера пакетов.
\poetry{} использует собственный решатель зависимостей, который сообщит об ошибке в подобной ситуации.
С данным изменением был оформлен Pull Request, который будет влит в основную ветку после окончания семестра.
