@article{2024GoduKolichestvo,
  entrysubtype = {newspaper},
  title = {В 2024 году количество бюджетных мест в российских вузах будет увеличено},
  journaltitle = {Министерство науки и высшего образования Российской Федерации},
  url = {https://minobrnauki.gov.ru/press-center/news/novosti-ministerstva/74773/},
  urldate = {2024-05-27},
  abstract = {Координационный совет при Правительстве РФ по вопросам планирования и распределения контрольных цифр приема на обучение по образовательным программам высшего образования одобрил общий объем бюджетных мест, который будет распределен российским вузам на 2024 год. На основании этого решения до 1 ноября Минобрнауки России выпустит соответствующий приказ. Заседание Координационного совета прошло под председательством главы Минобрнауки России Валерия Фалькова.},
  langid = {russian}
}

@online{abzalovGLLbasedContextFreePath2023,
  title = {{{GLL-based Context-Free Path Querying}} for {{Neo4j}}},
  author = {Abzalov, Vadim and Pogozhelskaya, Vlada and Kutuev, Vladimir and Grigorev, Semyon},
  date = {2023-12-19},
  eprint = {2312.11925},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2312.11925},
  url = {http://arxiv.org/abs/2312.11925},
  urldate = {2024-05-31},
  abstract = {We propose GLL-based context-free path querying algorithm which handles queries in Extended Backus-Naur Form (EBNF) using Recursive State Machines (RSM). Utilization of EBNF allows one to combine traditional regular expressions and mutually recursive patterns in constraints natively. The proposed algorithm solves both the reachability-only and the all-paths problems for the all-pairs and the multiple sources cases. The evaluation on realworld graphs demonstrates that utilization of RSMs increases performance of query evaluation. Being implemented as a stored procedure for Neo4j, our solution demonstrates better performance than a similar solution for RedisGraph. Performance of our solution of regular path queries is comparable with performance of native Neo4j solution, and in some cases our solution requires significantly less memory.},
  pubstate = {preprint},
  version = {1},
  keywords = {Computer Science - Databases}
}

@inproceedings{azimovContextfreePathQuerying2018,
  title = {Context-Free Path Querying by Matrix Multiplication},
  author = {Azimov, Rustam and Grigorev, Semyon},
  date = {2018-06-10},
  pages = {1--10},
  doi = {10.1145/3210259.3210264},
  abstract = {Context-free path querying is a technique, which recently gains popularity in many areas, for example, graph databases, bioinformatics, static analysis, etc. In some of these areas, it is often required to query large graphs, and existing algorithms demonstrate a poor performance in this case. The generalization of matrix-based Valiant's context-free language recognition algorithm for graph case is widely considered as a recipe for efficient context-free path querying; however, no progress has been made in this direction so far. We propose the first generalization of matrix-based Valiant's algorithm for context-free path querying. Our generalization does not deliver a truly sub-cubic worst-case complexity algorithm, whose existence still remains a hard open problem in the area. On the other hand, the utilization of matrix operations (such as matrix multiplication) in the process of context-free path query evaluation makes it possible to efficiently apply a wide class of optimizations and computing techniques, such as GPGPU (General-Purpose computing on Graphics Processing Units), parallel processing, sparse matrix representation, distributed-memory computation, etc. Indeed, the evaluation on a set of conventional benchmarks shows, that our algorithm outperforms the existing ones.}
}

@online{draghiciSemEnovArithmetic2023a,
  title = {Sem\textbackslash "enov {{Arithmetic}}, {{Affine VASS}}, and {{String Constraints}}},
  author = {Draghici, Andrei and Haase, Christoph and Manea, Florin},
  date = {2023-06-26},
  eprint = {2306.14593},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2306.14593},
  url = {http://arxiv.org/abs/2306.14593},
  urldate = {2024-05-27},
  abstract = {We study extensions of Sem\textbackslash "enov arithmetic, the first-order theory of the structure \$(\textbackslash mathbb\{N\}, +, 2\textasciicircum x)\$. It is well-knonw that this theory becomes undecidable when extended with regular predicates over tuples of number strings, such as the B\textbackslash "uchi \$V\_2\$-predicate. We therefore restrict ourselves to the existential theory of Sem\textbackslash "enov arithmetic and show that this theory is decidable in EXPSPACE when extended with arbitrary regular predicates over tuples of number strings. Our approach relies on a reduction to the language emptiness problem for a restricted class of affine vector addition systems with states, which we show decidable in EXPSPACE. As an application of our results, we settle an open problem from the literature and show decidability of a class of string constraints involving length constraints.},
  pubstate = {preprint},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science}
}

@article{dyrkaEstimatingProbabilisticContextfree2019,
  title = {Estimating Probabilistic Context-Free Grammars for Proteins Using Contact Map Constraints},
  author = {Dyrka, Witold and Pyzik, Mateusz and Coste, François and Talibart, Hugo},
  date = {2019-03-18},
  journaltitle = {PeerJ},
  shortjournal = {PeerJ},
  volume = {7},
  eprint = {30918754},
  eprinttype = {pmid},
  pages = {e6559},
  issn = {2167-8359},
  doi = {10.7717/peerj.6559},
  url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6428041/},
  urldate = {2024-05-27},
  abstract = {Interactions between amino acids that are close in the spatial structure, but not necessarily in the sequence, play important structural and functional roles in proteins. These non-local interactions ought to be taken into account when modeling collections of proteins. Yet the most popular representations of sets of related protein sequences remain the profile Hidden Markov Models. By modeling independently the distributions of the conserved columns from an underlying multiple sequence alignment of the proteins, these models are unable to capture dependencies between the protein residues. Non-local interactions can be represented by using more expressive grammatical models. However, learning such grammars is difficult. In this work, we propose to use information on protein contacts to facilitate the training of probabilistic context-free grammars representing families of protein sequences. We develop the theory behind the introduction of contact constraints in maximum-likelihood and contrastive estimation schemes and implement it in a machine learning framework for protein grammars. The proposed framework is tested on samples of protein motifs in comparison with learning without contact constraints. The evaluation shows high fidelity of grammatical descriptors to protein structures and improved precision in recognizing sequences. Finally, we present an example of using our method in a practical setting and demonstrate its potential beyond the current state of the art by creating a grammatical model of a meta-family of protein motifs. We conclude that the current piece of research is a significant step towards more flexible and accurate modeling of collections of protein sequences. The software package is made available to the community.},
  pmcid = {PMC6428041}
}

@inproceedings{elekesGraphBLASSolutionSIGMOD2020,
  title = {A {{GraphBLAS}} Solution to the {{SIGMOD}} 2014 {{Programming Contest}} Using Multi-Source {{BFS}}},
  booktitle = {2020 {{IEEE High Performance Extreme Computing Conference}} ({{HPEC}})},
  author = {Elekes, Marton and Nagy, Attila and Sandor, David and Antal, Janos Benjamin and Davis, Timothy A. and Szarnyas, Gabor},
  date = {2020-09-22},
  pages = {1--7},
  publisher = {IEEE},
  location = {Waltham, MA, USA},
  doi = {10.1109/HPEC43674.2020.9286186},
  url = {https://ieeexplore.ieee.org/document/9286186/},
  urldate = {2024-05-31},
  abstract = {The GraphBLAS standard defines a set of fundamental building blocks for formulating graph algorithms in the language of linear algebra. Since its first release in 2017, the expressivity of the GraphBLAS API and the performance of its implementations (such as SuiteSparse:GraphBLAS) have been studied on a number of textbook graph algorithms such as BFS, single-source shortest path, and connected components. However, less attention was devoted to other aspects of graph processing such as handling typed and attributed graphs (also known as property graphs), and making use of complex graph query techniques (handling paths, aggregation, and filtering). To study these problems in more detail, we have used GraphBLAS to solve the case study of the 2014 SIGMOD Programming Contest, which defines complex graph processing tasks that require a diverse set of operations. Our solution makes heavy use of multi-source BFS algorithms expressed as sparse matrix-matrix multiplications along with other GraphBLAS techniques such as masking and submatrix extraction. While the queries can be formulated in GraphBLAS concisely, our performance evaluation shows mixed results. For some queries and data sets, the performance is competitive with the hand-optimized top solutions submitted to the contest, however, in some cases, it is currently outperformed by orders of magnitude.},
  eventtitle = {2020 {{IEEE High Performance Extreme Computing Conference}} ({{HPEC}})},
  isbn = {978-1-72819-219-2},
  langid = {english}
}

@online{GeneratingGrammarconformantTexts,
  title = {Generating Grammar-Conformant Texts from {{ANTLR}} Grammars (or Other Way)?},
  url = {https://groups.google.com/g/antlr-discussion/c/6aatRq-IH1U?pli=1},
  urldate = {2024-05-26}
}

@book{gruneParsingTechniques2008,
  title = {Parsing {{Techniques}}},
  author = {Grune, Dick and Jacobs, Ceriel J. H.},
  date = {2008},
  series = {Monographs in {{Computer Science}}},
  publisher = {Springer},
  location = {New York, NY},
  doi = {10.1007/978-0-387-68954-8},
  url = {http://link.springer.com/10.1007/978-0-387-68954-8},
  urldate = {2024-05-27},
  isbn = {978-0-387-20248-8 978-0-387-68954-8},
  keywords = {algorithm,Algorithms,automata,browser,compiler,computational linguistics,data compression,linguistics,Parsing,programming,programming language,Syntax}
}

@online{guhaParikhAutomataInfinite2022,
  title = {Parikh {{Automata}} over {{Infinite Words}}},
  author = {Guha, Shibashis and Jecker, Ismaël and Lehtinen, Karoliina and Zimmermann, Martin},
  date = {2022-12-20},
  eprint = {2207.07694},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2207.07694},
  url = {http://arxiv.org/abs/2207.07694},
  urldate = {2024-05-27},
  abstract = {Parikh automata extend finite automata by counters that can be tested for membership in a semilinear set, but only at the end of a run, thereby preserving many of the desirable algorithmic properties of finite automata. Here, we study the extension of the classical framework onto infinite inputs: We introduce reachability, safety, B\textbackslash "uchi, and co-B\textbackslash "uchi Parikh automata on infinite words and study expressiveness, closure properties, and the complexity of verification problems. We show that almost all classes of automata have pairwise incomparable expressiveness, both in the deterministic and the nondeterministic case; a result that sharply contrasts with the well-known hierarchy in the \$\textbackslash omega\$-regular setting. Furthermore, emptiness is shown decidable for Parikh automata with reachability or B\textbackslash "uchi acceptance, but undecidable for safety and co-B\textbackslash "uchi acceptance. Most importantly, we show decidability of model checking with specifications given by deterministic Parikh automata with safety or co-B\textbackslash "uchi acceptance, but also undecidability for all other types of automata. Finally, solving games is undecidable for all types.},
  pubstate = {preprint},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science}
}

@dataset{hellingsConjunctiveContextFreePath2014,
  title = {Conjunctive {{Context-Free Path Queries}}},
  author = {Hellings, Jelle},
  date = {2014},
  publisher = {OpenProceedings.org},
  doi = {10.5441/002/ICDT.2014.15},
  url = {https://openproceedings.org/ICDT/2014/paper_34.pdf},
  urldate = {2024-05-31},
  abstract = {In graph query languages, regular expressions are commonly used to specify the labeling of paths. A natural step in increasing the expressive power of these query languages is replacing regular expressions by context-free grammars. With the Conjunctive Context-Free Path Queries (CCFPQ) we introduce such a language based on the well-known Conjunctive Regular Path Queries (CRPQ).},
  langid = {english},
  keywords = {Database Technology,Database Theory}
}

@online{hellingsQueryingPathsGraphs2016,
  title = {Querying for {{Paths}} in {{Graphs}} Using {{Context-Free Path Queries}}},
  author = {Hellings, Jelle},
  date = {2016-01-31},
  eprint = {1502.02242},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.1502.02242},
  url = {http://arxiv.org/abs/1502.02242},
  urldate = {2024-05-27},
  abstract = {Navigational queries for graph-structured data, such as the regular path queries and the context-free path queries, are usually evaluated to a relation of node-pairs \$(m, n)\$ such that there is a path from \$m\$ to \$n\$ satisfying the conditions of the query. Although this relational query semantics has practical value, we believe that the relational query semantics can only provide limited insight in the structure of the graph data. To address the limits of the relational query semantics, we introduce the all-path query semantics and the single-path query semantics. Under these path-based query semantics, a query is evaluated to all paths satisfying the conditions of the query, or, respectively, to a single such path. While focusing on context-free path queries, we provide a formal framework for evaluating queries on graphs using both path-based query semantics. For the all-path query semantics, we show that the result of a query can be represented by a finite context-free grammar annotated with node-information relevant for deriving each path in the query result. For the single-path query semantics, we propose to search for a path of minimum length. We reduce the problem of finding such a path of minimum length to finding a string of minimum length in a context-free language, and for deriving such a string we propose a novel algorithm. Our initial results show that the path-based query semantics have added practical value and that query evaluation for both path-based query semantics is feasible, even when query results grow very large. For the single-path query semantics, determining strict worst-case upper bounds on the size of the query result remains the focus of future work.},
  pubstate = {preprint},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Databases}
}

@inproceedings{noleRegularPathQueries2016,
  title = {Regular {{Path Queries}} on {{Massive Graphs}}},
  booktitle = {Proceedings of the 28th {{International Conference}} on {{Scientific}} and {{Statistical Database Management}}},
  author = {Nolé, Maurizio and Sartiani, Carlo},
  date = {2016-07-18},
  series = {{{SSDBM}} '16},
  pages = {1--12},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/2949689.2949711},
  url = {https://doi.org/10.1145/2949689.2949711},
  urldate = {2024-05-27},
  abstract = {Regular Path Queries (RPQs) represent a powerful tool for querying graph databases and are of particular interest, because they form the building blocks of other query languages, and because they can be used in many theoretical or practical contexts for different purposes. In this paper we present a novel system for processing regular path queries on massive data graphs. As confirmed by an extensive experimental evaluation, our system scales linearly with the number of vertices and/or edges, and it can efficiently query graphs up to a billion vertices and 100 billion edges.},
  isbn = {978-1-4503-4215-5}
}

@incollection{orachevContextFreePathQuerying2020,
  title = {Context-{{Free Path Querying}} by {{Kronecker Product}}},
  author = {Orachev, Egor and Epelbaum, Ilya and Azimov, Rustam and Grigorev, Semyon},
  date = {2020-08-17},
  pages = {49--59},
  doi = {10.1007/978-3-030-54832-2_6},
  abstract = {Context-free path queries (CFPQ) extend the regular path queries (RPQ) by allowing context-free grammars to be used as constraints for paths. Algorithms for CFPQ are actively developed, but J. Kuijpers et al. have recently concluded, that existing algorithms are not performant enough to be used in real-world applications. Thus the development of new algorithms for CFPQ is justified. In this paper, we provide a new CFPQ algorithm which is based on such linear algebra operations as Kronecker product and transitive closure and handles grammars presented as recursive state machines. Thus, the proposed algorithm can be implemented by using high-performance libraries and modern parallel hardware. Moreover, it avoids grammar growth which provides the possibility for queries optimization.},
  isbn = {978-3-030-54831-5}
}

@book{parrDefinitiveANTLRReference2013,
  title = {The {{Definitive ANTLR}} 4 {{Reference}}},
  author = {Parr, Terence},
  date = {2013},
  edition = {2},
  publisher = {Pragmatic Bookshelf},
  abstract = {Programmers run into parsing problems all the time. Whether it's a data format like JSON, a network protocol like SMTP, a server configuration file for Apache, a PostScript/PDF file, or a simple spreadsheet macro language--ANTLR v4 and this book will demystify the process. ANTLR v4 has been rewritten from scratch to make it easier than ever to build parsers and the language applications built on top. This completely rewritten new edition of the bestselling Definitive ANTLR Reference shows you how to take advantage of these new features. Build your own languages with ANTLR v4, using ANTLR's new advanced parsing technology. In this book, you'll learn how ANTLR automatically builds a data structure representing the input (parse tree) and generates code that can walk the tree (visitor). You can use that combination to implement data readers, language interpreters, and translators. You'll start by learning how to identify grammar patterns in language reference manuals and then slowly start building increasingly complex grammars. Next, you'll build applications based upon those grammars by walking the automatically generated parse trees. Then you'll tackle some nasty language problems by parsing files containing more than one language (such as XML, Java, and Javadoc). You'll also see how to take absolute control over parsing by embedding Java actions into the grammar. You'll learn directly from well-known parsing expert Terence Parr, the ANTLR creator and project lead. You'll master ANTLR grammar construction and learn how to build language tools using the built-in parse tree visitor mechanism. The book teaches using real-world examples and shows you how to use ANTLR to build such things as a data file reader, a JSON to XML translator, an R parser, and a Java class-interface extractor. This book is your ticket to becoming a parsing guru!What You Need: ANTLR 4.0 and above. Java development tools. Ant build system optional (needed for building ANTLR from source)},
  isbn = {978-1-934356-99-9},
  pagetotal = {328}
}

@inproceedings{romeroPyformlangEducationalLibrary2021,
  title = {Pyformlang: {{An Educational Library}} for {{Formal Language Manipulation}}},
  shorttitle = {Pyformlang},
  booktitle = {Proceedings of the 52nd {{ACM Technical Symposium}} on {{Computer Science Education}}},
  author = {Romero, Julien},
  date = {2021-03-05},
  series = {{{SIGCSE}} '21},
  pages = {576--582},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3408877.3432464},
  url = {https://dl.acm.org/doi/10.1145/3408877.3432464},
  urldate = {2024-05-27},
  abstract = {Formal languages are widely studied, taught and used in computer science. However, only a small part of this domain is brought to a broader audience, and students often have no practical experience in their curriculum. In this tool paper, we introduce Pyformlang, a practical and pedagogical Python library for formal languages. Our library implements the most common algorithms of the domain, accessible by an easy-to-use interface. The code is written exclusively in Python3, with a clear structure, so as to allow students to play and learn with it.},
  isbn = {978-1-4503-8062-1},
  keywords = {education,formal languages,library,python}
}

@inproceedings{SciPyProceedings_11,
  title = {Exploring Network Structure, Dynamics, and Function Using {{NetworkX}}},
  booktitle = {Proceedings of the 7th Python in Science Conference},
  author = {Hagberg, Aric A. and Schult, Daniel A. and Swart, Pieter J.},
  editor = {Varoquaux, Gaël and Vaught, Travis and Millman, Jarrod},
  date = {2008},
  pages = {11--15},
  location = {Pasadena, CA USA}
}

@article{scottGLLParsing2010,
  title = {{{GLL Parsing}}},
  author = {Scott, Elizabeth and Johnstone, Adrian},
  date = {2010-09-17},
  journaltitle = {Electronic Notes in Theoretical Computer Science},
  shortjournal = {Electronic Notes in Theoretical Computer Science},
  series = {Proceedings of the {{Ninth Workshop}} on {{Language Descriptions Tools}} and {{Applications}} ({{LDTA}} 2009)},
  volume = {253},
  number = {7},
  pages = {177--189},
  issn = {1571-0661},
  doi = {10.1016/j.entcs.2010.08.041},
  url = {https://www.sciencedirect.com/science/article/pii/S1571066110001209},
  urldate = {2024-05-29},
  abstract = {Recursive Descent (RD) parsers are popular because their control flow follows the structure of the grammar and hence they are easy to write and to debug. However, the class of grammars which admit RD parsers is very limited. Backtracking techniques may be used to extend this class, but can have explosive runtimes and cannot deal with grammars with left recursion. Tomita-style RNGLR parsers are fully general but are based on LR techniques and do not have the direct relationship with the grammar that an RD parser has. We develop the fully general GLL parsing technique which is recursive descent-like, and has the property that the parse follows closely the structure of the grammar rules, but uses RNGLR-like machinery to handle non-determinism. The resulting recognisers run in worst-case cubic time and can be built even for left recursive grammars.},
  keywords = {context free languages,generalised parsing,recursive descent,RNGLR and RIGLR parsing}
}

@online{shemetovaOneAlgorithmEvaluate2021,
  title = {One {{Algorithm}} to {{Evaluate Them All}}: {{Unified Linear Algebra Based Approach}} to {{Evaluate Both Regular}} and {{Context-Free Path Queries}}},
  shorttitle = {One {{Algorithm}} to {{Evaluate Them All}}},
  author = {Shemetova, Ekaterina and Azimov, Rustam and Orachev, Egor and Epelbaum, Ilya and Grigorev, Semyon},
  date = {2021-03-26},
  eprint = {2103.14688},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2103.14688},
  url = {http://arxiv.org/abs/2103.14688},
  urldate = {2024-05-31},
  abstract = {The Kronecker product-based algorithm for context-free path querying (CFPQ) was proposed by Orachev et al. (2020). We reduce this algorithm to operations over Boolean matrices and extend it with the mechanism to extract all paths of interest. We also prove \$O(n\textasciicircum 3/\textbackslash log\{n\})\$ time complexity of the proposed algorithm, where n is a number of vertices of the input graph. Thus, we provide the alternative way to construct a slightly subcubic algorithm for CFPQ which is based on linear algebra and incremental transitive closure (a classic graph-theoretic problem), as opposed to the algorithm with the same complexity proposed by Chaudhuri (2008). Our evaluation shows that our algorithm is a good candidate to be the universal algorithm for both regular and context-free path querying.},
  pubstate = {preprint},
  keywords = {Computer Science - Databases,Computer Science - Programming Languages}
}

@article{virtanenSciPyFundamentalAlgorithms2020,
  title = {{{SciPy}} 1.0: Fundamental Algorithms for Scientific Computing in {{Python}}},
  shorttitle = {{{SciPy}} 1.0},
  author = {Virtanen, Pauli and Gommers, Ralf and Oliphant, Travis E. and Haberland, Matt and Reddy, Tyler and Cournapeau, David and Burovski, Evgeni and Peterson, Pearu and Weckesser, Warren and Bright, Jonathan and family=Walt, given=Stéfan J., prefix=van der, useprefix=true and Brett, Matthew and Wilson, Joshua and Millman, K. Jarrod and Mayorov, Nikolay and Nelson, Andrew R. J. and Jones, Eric and Kern, Robert and Larson, Eric and Carey, C. J. and Polat, İlhan and Feng, Yu and Moore, Eric W. and VanderPlas, Jake and Laxalde, Denis and Perktold, Josef and Cimrman, Robert and Henriksen, Ian and Quintero, E. A. and Harris, Charles R. and Archibald, Anne M. and Ribeiro, Antônio H. and Pedregosa, Fabian and family=Mulbregt, given=Paul, prefix=van, useprefix=true},
  date = {2020-03},
  journaltitle = {Nature Methods},
  shortjournal = {Nat Methods},
  volume = {17},
  number = {3},
  pages = {261--272},
  publisher = {Nature Publishing Group},
  issn = {1548-7105},
  doi = {10.1038/s41592-019-0686-2},
  url = {https://www.nature.com/articles/s41592-019-0686-2},
  urldate = {2024-05-27},
  abstract = {SciPy is an open-source scientific computing library for the Python programming language. Since its initial release in 2001, SciPy has become a de facto standard for leveraging scientific algorithms in Python, with over 600 unique code contributors, thousands of dependent packages, over 100,000 dependent repositories and millions of downloads per year. In this work, we provide an overview of the capabilities and development practices of SciPy 1.0 and highlight some recent technical developments. This Perspective describes the development and capabilities of SciPy 1.0, an open source scientific computing library for the Python programming language.},
  langid = {english},
  keywords = {Biophysical chemistry,Computational biology and bioinformatics,Technology}
}

@article{wjandersonEvolvingStochasticContext2012,
  title = {Evolving Stochastic Context--Free Grammars for {{RNA}} Secondary Structure Prediction},
  author = {WJ Anderson, James and Tataru, Paula and Staines, Joe and Hein, Jotun and Lyngsø, Rune},
  date = {2012-05-04},
  journaltitle = {BMC Bioinformatics},
  shortjournal = {BMC Bioinformatics},
  volume = {13},
  eprint = {22559985},
  eprinttype = {pmid},
  pages = {78},
  issn = {1471-2105},
  doi = {10.1186/1471-2105-13-78},
  url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3464655/},
  urldate = {2024-05-27},
  abstract = {Background Stochastic Context–Free Grammars (SCFGs) were applied successfully to RNA secondary structure prediction in the early 90s, and used in combination with comparative methods in the late 90s. The set of SCFGs potentially useful for RNA secondary structure prediction is very large, but a few intuitively designed grammars have remained dominant. In this paper we investigate two automatic search techniques for effective grammars – exhaustive search for very compact grammars and an evolutionary algorithm to find larger grammars. We also examine whether grammar ambiguity is as problematic to structure prediction as has been previously suggested. Results These search techniques were applied to predict RNA secondary structure on a maximal data set and revealed new and interesting grammars, though none are dramatically better than classic grammars. In general, results showed that many grammars with quite different structure could have very similar predictive ability. Many ambiguous grammars were found which were at least as effective as the best current unambiguous grammars. Conclusions Overall the method of evolving SCFGs for RNA secondary structure prediction proved effective in finding many grammars that had strong predictive accuracy, as good or slightly better than those designed manually. Furthermore, several of the best grammars found were ambiguous, demonstrating that such grammars should not be disregarded.},
  pmcid = {PMC3464655}
}
