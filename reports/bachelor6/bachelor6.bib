@article{2024GoduKolichestvo,
  entrysubtype = {newspaper},
  title = {В 2024 году количество бюджетных мест в российских вузах будет увеличено},
  journaltitle = {Министерство науки и высшего образования Российской Федерации},
  url = {https://minobrnauki.gov.ru/press-center/news/novosti-ministerstva/74773/},
  urldate = {2024-05-27},
  abstract = {Координационный совет при Правительстве РФ по вопросам планирования и распределения контрольных цифр приема на обучение по образовательным программам высшего образования одобрил общий объем бюджетных мест, который будет распределен российским вузам на 2024 год. На основании этого решения до 1 ноября Минобрнауки России выпустит соответствующий приказ. Заседание Координационного совета прошло под председательством главы Минобрнауки России Валерия Фалькова.},
  langid = {russian}
}

@online{draghiciSemEnovArithmetic2023a,
  title = {Sem\textbackslash "enov {{Arithmetic}}, {{Affine VASS}}, and {{String Constraints}}},
  author = {Draghici, Andrei and Haase, Christoph and Manea, Florin},
  date = {2023-06-26},
  eprint = {2306.14593},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2306.14593},
  url = {http://arxiv.org/abs/2306.14593},
  urldate = {2024-05-27},
  abstract = {We study extensions of Sem\textbackslash "enov arithmetic, the first-order theory of the structure \$(\textbackslash mathbb\{N\}, +, 2\textasciicircum x)\$. It is well-knonw that this theory becomes undecidable when extended with regular predicates over tuples of number strings, such as the B\textbackslash "uchi \$V\_2\$-predicate. We therefore restrict ourselves to the existential theory of Sem\textbackslash "enov arithmetic and show that this theory is decidable in EXPSPACE when extended with arbitrary regular predicates over tuples of number strings. Our approach relies on a reduction to the language emptiness problem for a restricted class of affine vector addition systems with states, which we show decidable in EXPSPACE. As an application of our results, we settle an open problem from the literature and show decidability of a class of string constraints involving length constraints.},
  pubstate = {preprint},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science}
}

@article{dyrkaEstimatingProbabilisticContextfree2019,
  title = {Estimating Probabilistic Context-Free Grammars for Proteins Using Contact Map Constraints},
  author = {Dyrka, Witold and Pyzik, Mateusz and Coste, François and Talibart, Hugo},
  date = {2019-03-18},
  journaltitle = {PeerJ},
  shortjournal = {PeerJ},
  volume = {7},
  eprint = {30918754},
  eprinttype = {pmid},
  pages = {e6559},
  issn = {2167-8359},
  doi = {10.7717/peerj.6559},
  url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6428041/},
  urldate = {2024-05-27},
  abstract = {Interactions between amino acids that are close in the spatial structure, but not necessarily in the sequence, play important structural and functional roles in proteins. These non-local interactions ought to be taken into account when modeling collections of proteins. Yet the most popular representations of sets of related protein sequences remain the profile Hidden Markov Models. By modeling independently the distributions of the conserved columns from an underlying multiple sequence alignment of the proteins, these models are unable to capture dependencies between the protein residues. Non-local interactions can be represented by using more expressive grammatical models. However, learning such grammars is difficult. In this work, we propose to use information on protein contacts to facilitate the training of probabilistic context-free grammars representing families of protein sequences. We develop the theory behind the introduction of contact constraints in maximum-likelihood and contrastive estimation schemes and implement it in a machine learning framework for protein grammars. The proposed framework is tested on samples of protein motifs in comparison with learning without contact constraints. The evaluation shows high fidelity of grammatical descriptors to protein structures and improved precision in recognizing sequences. Finally, we present an example of using our method in a practical setting and demonstrate its potential beyond the current state of the art by creating a grammatical model of a meta-family of protein motifs. We conclude that the current piece of research is a significant step towards more flexible and accurate modeling of collections of protein sequences. The software package is made available to the community.},
  pmcid = {PMC6428041}
}

@online{GeneratingGrammarconformantTexts,
  title = {Generating Grammar-Conformant Texts from {{ANTLR}} Grammars (or Other Way)?},
  url = {https://groups.google.com/g/antlr-discussion/c/6aatRq-IH1U?pli=1},
  urldate = {2024-05-26}
}

@book{gruneParsingTechniques2008,
  title = {Parsing {{Techniques}}},
  author = {Grune, Dick and Jacobs, Ceriel J. H.},
  date = {2008},
  series = {Monographs in {{Computer Science}}},
  publisher = {Springer},
  location = {New York, NY},
  doi = {10.1007/978-0-387-68954-8},
  url = {http://link.springer.com/10.1007/978-0-387-68954-8},
  urldate = {2024-05-27},
  isbn = {978-0-387-20248-8 978-0-387-68954-8},
  keywords = {algorithm,Algorithms,automata,browser,compiler,computational linguistics,data compression,linguistics,Parsing,programming,programming language,Syntax}
}

@online{guhaParikhAutomataInfinite2022,
  title = {Parikh {{Automata}} over {{Infinite Words}}},
  author = {Guha, Shibashis and Jecker, Ismaël and Lehtinen, Karoliina and Zimmermann, Martin},
  date = {2022-12-20},
  eprint = {2207.07694},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2207.07694},
  url = {http://arxiv.org/abs/2207.07694},
  urldate = {2024-05-27},
  abstract = {Parikh automata extend finite automata by counters that can be tested for membership in a semilinear set, but only at the end of a run, thereby preserving many of the desirable algorithmic properties of finite automata. Here, we study the extension of the classical framework onto infinite inputs: We introduce reachability, safety, B\textbackslash "uchi, and co-B\textbackslash "uchi Parikh automata on infinite words and study expressiveness, closure properties, and the complexity of verification problems. We show that almost all classes of automata have pairwise incomparable expressiveness, both in the deterministic and the nondeterministic case; a result that sharply contrasts with the well-known hierarchy in the \$\textbackslash omega\$-regular setting. Furthermore, emptiness is shown decidable for Parikh automata with reachability or B\textbackslash "uchi acceptance, but undecidable for safety and co-B\textbackslash "uchi acceptance. Most importantly, we show decidability of model checking with specifications given by deterministic Parikh automata with safety or co-B\textbackslash "uchi acceptance, but also undecidability for all other types of automata. Finally, solving games is undecidable for all types.},
  pubstate = {preprint},
  keywords = {Computer Science - Formal Languages and Automata Theory,Computer Science - Logic in Computer Science}
}

@online{hellingsQueryingPathsGraphs2016,
  title = {Querying for {{Paths}} in {{Graphs}} Using {{Context-Free Path Queries}}},
  author = {Hellings, Jelle},
  date = {2016-01-31},
  eprint = {1502.02242},
  eprinttype = {arxiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.1502.02242},
  url = {http://arxiv.org/abs/1502.02242},
  urldate = {2024-05-27},
  abstract = {Navigational queries for graph-structured data, such as the regular path queries and the context-free path queries, are usually evaluated to a relation of node-pairs \$(m, n)\$ such that there is a path from \$m\$ to \$n\$ satisfying the conditions of the query. Although this relational query semantics has practical value, we believe that the relational query semantics can only provide limited insight in the structure of the graph data. To address the limits of the relational query semantics, we introduce the all-path query semantics and the single-path query semantics. Under these path-based query semantics, a query is evaluated to all paths satisfying the conditions of the query, or, respectively, to a single such path. While focusing on context-free path queries, we provide a formal framework for evaluating queries on graphs using both path-based query semantics. For the all-path query semantics, we show that the result of a query can be represented by a finite context-free grammar annotated with node-information relevant for deriving each path in the query result. For the single-path query semantics, we propose to search for a path of minimum length. We reduce the problem of finding such a path of minimum length to finding a string of minimum length in a context-free language, and for deriving such a string we propose a novel algorithm. Our initial results show that the path-based query semantics have added practical value and that query evaluation for both path-based query semantics is feasible, even when query results grow very large. For the single-path query semantics, determining strict worst-case upper bounds on the size of the query result remains the focus of future work.},
  pubstate = {preprint},
  keywords = {Computer Science - Data Structures and Algorithms,Computer Science - Databases}
}

@inproceedings{noleRegularPathQueries2016,
  title = {Regular {{Path Queries}} on {{Massive Graphs}}},
  booktitle = {Proceedings of the 28th {{International Conference}} on {{Scientific}} and {{Statistical Database Management}}},
  author = {Nolé, Maurizio and Sartiani, Carlo},
  date = {2016-07-18},
  series = {{{SSDBM}} '16},
  pages = {1--12},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/2949689.2949711},
  url = {https://doi.org/10.1145/2949689.2949711},
  urldate = {2024-05-27},
  abstract = {Regular Path Queries (RPQs) represent a powerful tool for querying graph databases and are of particular interest, because they form the building blocks of other query languages, and because they can be used in many theoretical or practical contexts for different purposes. In this paper we present a novel system for processing regular path queries on massive data graphs. As confirmed by an extensive experimental evaluation, our system scales linearly with the number of vertices and/or edges, and it can efficiently query graphs up to a billion vertices and 100 billion edges.},
  isbn = {978-1-4503-4215-5}
}

@book{parrDefinitiveANTLRReference2013,
  title = {The {{Definitive ANTLR}} 4 {{Reference}}},
  author = {Parr, Terence},
  date = {2013},
  edition = {2},
  publisher = {Pragmatic Bookshelf},
  abstract = {Programmers run into parsing problems all the time. Whether it's a data format like JSON, a network protocol like SMTP, a server configuration file for Apache, a PostScript/PDF file, or a simple spreadsheet macro language--ANTLR v4 and this book will demystify the process. ANTLR v4 has been rewritten from scratch to make it easier than ever to build parsers and the language applications built on top. This completely rewritten new edition of the bestselling Definitive ANTLR Reference shows you how to take advantage of these new features. Build your own languages with ANTLR v4, using ANTLR's new advanced parsing technology. In this book, you'll learn how ANTLR automatically builds a data structure representing the input (parse tree) and generates code that can walk the tree (visitor). You can use that combination to implement data readers, language interpreters, and translators. You'll start by learning how to identify grammar patterns in language reference manuals and then slowly start building increasingly complex grammars. Next, you'll build applications based upon those grammars by walking the automatically generated parse trees. Then you'll tackle some nasty language problems by parsing files containing more than one language (such as XML, Java, and Javadoc). You'll also see how to take absolute control over parsing by embedding Java actions into the grammar. You'll learn directly from well-known parsing expert Terence Parr, the ANTLR creator and project lead. You'll master ANTLR grammar construction and learn how to build language tools using the built-in parse tree visitor mechanism. The book teaches using real-world examples and shows you how to use ANTLR to build such things as a data file reader, a JSON to XML translator, an R parser, and a Java class-interface extractor. This book is your ticket to becoming a parsing guru!What You Need: ANTLR 4.0 and above. Java development tools. Ant build system optional (needed for building ANTLR from source)},
  isbn = {978-1-934356-99-9},
  pagetotal = {328}
}

@inproceedings{romeroPyformlangEducationalLibrary2021,
  title = {Pyformlang: {{An Educational Library}} for {{Formal Language Manipulation}}},
  shorttitle = {Pyformlang},
  booktitle = {Proceedings of the 52nd {{ACM Technical Symposium}} on {{Computer Science Education}}},
  author = {Romero, Julien},
  date = {2021-03-05},
  series = {{{SIGCSE}} '21},
  pages = {576--582},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/3408877.3432464},
  url = {https://dl.acm.org/doi/10.1145/3408877.3432464},
  urldate = {2024-05-27},
  abstract = {Formal languages are widely studied, taught and used in computer science. However, only a small part of this domain is brought to a broader audience, and students often have no practical experience in their curriculum. In this tool paper, we introduce Pyformlang, a practical and pedagogical Python library for formal languages. Our library implements the most common algorithms of the domain, accessible by an easy-to-use interface. The code is written exclusively in Python3, with a clear structure, so as to allow students to play and learn with it.},
  isbn = {978-1-4503-8062-1},
  keywords = {education,formal languages,library,python}
}

@inproceedings{SciPyProceedings_11,
  title = {Exploring Network Structure, Dynamics, and Function Using {{NetworkX}}},
  booktitle = {Proceedings of the 7th Python in Science Conference},
  author = {Hagberg, Aric A. and Schult, Daniel A. and Swart, Pieter J.},
  editor = {Varoquaux, Gaël and Vaught, Travis and Millman, Jarrod},
  date = {2008},
  pages = {11--15},
  location = {Pasadena, CA USA}
}

@article{virtanenSciPyFundamentalAlgorithms2020,
  title = {{{SciPy}} 1.0: Fundamental Algorithms for Scientific Computing in {{Python}}},
  shorttitle = {{{SciPy}} 1.0},
  author = {Virtanen, Pauli and Gommers, Ralf and Oliphant, Travis E. and Haberland, Matt and Reddy, Tyler and Cournapeau, David and Burovski, Evgeni and Peterson, Pearu and Weckesser, Warren and Bright, Jonathan and family=Walt, given=Stéfan J., prefix=van der, useprefix=true and Brett, Matthew and Wilson, Joshua and Millman, K. Jarrod and Mayorov, Nikolay and Nelson, Andrew R. J. and Jones, Eric and Kern, Robert and Larson, Eric and Carey, C. J. and Polat, İlhan and Feng, Yu and Moore, Eric W. and VanderPlas, Jake and Laxalde, Denis and Perktold, Josef and Cimrman, Robert and Henriksen, Ian and Quintero, E. A. and Harris, Charles R. and Archibald, Anne M. and Ribeiro, Antônio H. and Pedregosa, Fabian and family=Mulbregt, given=Paul, prefix=van, useprefix=true},
  date = {2020-03},
  journaltitle = {Nature Methods},
  shortjournal = {Nat Methods},
  volume = {17},
  number = {3},
  pages = {261--272},
  publisher = {Nature Publishing Group},
  issn = {1548-7105},
  doi = {10.1038/s41592-019-0686-2},
  url = {https://www.nature.com/articles/s41592-019-0686-2},
  urldate = {2024-05-27},
  abstract = {SciPy is an open-source scientific computing library for the Python programming language. Since its initial release in 2001, SciPy has become a de facto standard for leveraging scientific algorithms in Python, with over 600 unique code contributors, thousands of dependent packages, over 100,000 dependent repositories and millions of downloads per year. In this work, we provide an overview of the capabilities and development practices of SciPy 1.0 and highlight some recent technical developments. This Perspective describes the development and capabilities of SciPy 1.0, an open source scientific computing library for the Python programming language.},
  langid = {english},
  keywords = {Biophysical chemistry,Computational biology and bioinformatics,Technology}
}

@article{wjandersonEvolvingStochasticContext2012,
  title = {Evolving Stochastic Context--Free Grammars for {{RNA}} Secondary Structure Prediction},
  author = {WJ Anderson, James and Tataru, Paula and Staines, Joe and Hein, Jotun and Lyngsø, Rune},
  date = {2012-05-04},
  journaltitle = {BMC Bioinformatics},
  shortjournal = {BMC Bioinformatics},
  volume = {13},
  eprint = {22559985},
  eprinttype = {pmid},
  pages = {78},
  issn = {1471-2105},
  doi = {10.1186/1471-2105-13-78},
  url = {https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3464655/},
  urldate = {2024-05-27},
  abstract = {Background Stochastic Context–Free Grammars (SCFGs) were applied successfully to RNA secondary structure prediction in the early 90s, and used in combination with comparative methods in the late 90s. The set of SCFGs potentially useful for RNA secondary structure prediction is very large, but a few intuitively designed grammars have remained dominant. In this paper we investigate two automatic search techniques for effective grammars – exhaustive search for very compact grammars and an evolutionary algorithm to find larger grammars. We also examine whether grammar ambiguity is as problematic to structure prediction as has been previously suggested. Results These search techniques were applied to predict RNA secondary structure on a maximal data set and revealed new and interesting grammars, though none are dramatically better than classic grammars. In general, results showed that many grammars with quite different structure could have very similar predictive ability. Many ambiguous grammars were found which were at least as effective as the best current unambiguous grammars. Conclusions Overall the method of evolving SCFGs for RNA secondary structure prediction proved effective in finding many grammars that had strong predictive accuracy, as good or slightly better than those designed manually. Furthermore, several of the best grammars found were ambiguous, demonstrating that such grammars should not be disregarded.},
  pmcid = {PMC3464655}
}
