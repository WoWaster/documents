% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор существующих решений}

Со времен публикации первых статей был разработан не один исполнитель \INs{}.
Обзор на момент 2014 года можно найти в работе~\cite{satoDesignImplementationLowlevel2015}.
Мы же приведём обзор более новых работ в данной области.

\paragraph{\texorpdfstring{\textsc{Inpla} и \textsc{Train}}{Inpla и Train}.}

\textsc{Inpla}\footnote{Репозиторий проекта: \url{https://github.com/inpla/inpla/} (дата обращения: \DTMdate{2025-02-15})}~--- интерпретатор одного из крупных учёных в области Shinya Sato, начатый в его PhD~\cite{satoDesignImplementationLowlevel2015}, и поддерживающий параллельное исполнение~\cite{mackieParallelEvaluationInteraction2016}.

\textsc{Inpla} предполагает описание сетей на собственном языке программирования, который тем не менее достаточно сложен для использования.
Транслятор \textsc{Train}\footnote{Репозиторий проекта: \url{https://github.com/inpla/train/} (дата обращения: \DTMdate{2025-02-15})} решает данную проблему, конвертируя код из функционального языка программирования в код для \textsc{Inpla}.
Весь комплекс реализован на C.

\paragraph{HVM 1, 2, 3 и \textsc{Bend}.}

Семейство проектов от стартапа \textsc{Higher Order Company}\footnote{\GitHub{} организация проекта: \url{https://github.com/HigherOrderCO/} (дата обращения: \DTMdate{2025-02-17})}.
HVM (Higher-order Virtual Machine) является средой исполнения \INs{}, эксплуатирующей параллельность, и существует в нескольких версиях, отличающихся языком реализации, стратегией вычислений и средой исполнения.
\begin{description}
      \item[HVM1] Написана на \textsc{Rust}, с ленивой стратегией вычисления на CPU.
            Считается устаревшей.
      \item[HVM2] Написана на \textsc{Rust}, со строгой стратегией, поддерживает как CPU через кодогенерацию в C, так и GPU через генерацию в CUDA.
            На данный момент является стабильной версией.
      \item[HVM3] Написана на \Haskell{}; поддерживает как ленивую, так и строгую стратегии вычисления на CPU.
            Является наследником HVM1 и HVM2 и создается, чтобы их заменить, находится в активной разработке.
\end{description}
HVM1 использовал собственный \Haskell{}-подобный синтаксис.
В HVM2 и HVM3 используется низкоуровневый функциональный язык.
Для облегчения жизни пользователей, с ними предполагает использовать высокоуровневый язык Bend, который будет транслироваться в низкоуровневое представление.

\paragraph{\textsc{lambda}.}

\textsc{lambda}\footnote{Репозиторий проекта: \url{https://github.com/codedot/lambda/} (дата обращения: \DTMdate{2025-02-17})}~--- интерпретатор $\lambda$-исчисления, реализованный на \textsc{JavaScript}, поддерживающий четыре стратегии трансляции в \INs{}~\cite{salikhmetovTokenpassingOptimalReduction2016}.
Принимает программы на собственном языке программирования, похожем на $\lambda$-исчисление.

\paragraph{\textsc{interact}.}

\textsc{interact}\footnote{Репозиторий проекта: \url{https://github.com/szeiger/interact/} (дата обращения: \DTMdate{2025-02-18})}~--- интерпретатор, написанный на \textsc{Scala}.
Имеет свой язык программирования, похожий на \OCaml{} и \textsc{Python}, где каждая функция становится агентом сети.

\paragraph{Выводы.}

Таким образом, несмотря на существование множества различных интерпретаторов, большинство из них используют свои собственные языки программирования, часто синтаксически далёкие от массовых, и не декларируют используемые наборы агентов.
Кроме того, на данный момент попыток разработать ускоритель на основе \INs{} не предпринималось.
