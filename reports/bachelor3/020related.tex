% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\subsection{Алгоритм CRC}
Алгоритм CRC был впервые представлен в 1961 году~\cite{4066263} для обнаружения ошибок при передаче данных по сетям без сложных математических вычислений.

Рассмотрим математические основы CRC.
Многочлен с коэффициентами над полем $\Ftwo$ может быть представлен как последовательность битов, где 1 на позиции $i$ означает наличие слагаемого $x^i$, а 0 его отсутствие.
Например, $x^5 + x^2 + x + 1$ может быть записан как $100111_2$.
Данное представление единственно, что позволяет сопоставлять бинарные последовательности с многочленами.

В таком случае операции над многочленами можно свести к операциям над битам.
Заметим, что сложение и вычитание многочленов над полем $\Ftwo$ являются операцией исключающего ИЛИ~(далее xor или $\oplus$) над битовым строками.
\begin{multline*}
    (x^5 + x^2 + x + 1) + (x^6 + x^4 + x^2 + 1) = 0100111_2 \oplus 1010101_2 = \\
    = 1110010_2 = x^6 + x^5 + x^4 + x
\end{multline*}
Умножение битовых последовательностей идентично умножению бинарных чисел, только без переноса единицы, поэтому умножать можно используя сдвиги влево (далее $\ll$) и xor.
\begin{multline*}
    (x^5 + x^2 + x + 1) \cdot (x^6 + x^4 + x^2 + 1) = 0100111_2 \cdot 1010101_2 = \\
    = 1010101_2 \oplus (1010101_2 \ll 1) \oplus (1010101_2 \ll 2) \oplus (1010101_2 \ll 5) = \\
    = 101100001011_2 = x^{11} + x^9 + x^8 + x^3 + x + 1
\end{multline*}
Деление тоже сводится к сдвигам: <<прикладываем>> делитель к началу делимого, если бит равен 1, то записываем 1 в частное и совершаем xor, иначе двигаемся вправо записывая все встреченные нули в частное, продолжаем до тех пор пока длина делимого не станет меньше длины делителя.
\[(x^6 + x^4 + x^2 + 1) : (x^5 + x^2 + x + 1) = 1010101_2 : 0100111_2 = 10_2 \]
Остаток при этом равен
\[(1010101_2 \oplus (100111_2 \ll 1)) \oplus 100111_2 = 11011_2\]

Пусть $M$~--- сообщение которые мы хотим защитить контрольными суммами.
Зафиксируем многочлен $P(x)$ степени $n$.
Умножим $M$ на $x^n$ и вычислим остаток от деления на $P(x)$.
Данный остаток и будет называться CRC.
\[R(x) = M(x) \cdot x^n \mod{P(x)}\]

\subsection{Реализации CRC-32}
Пусть $P(x)$ любой многочлен степени 32.
Тогда вычисление \crctt{} выполняется прямым способом: сообщение $M$ сдвигается на 32 бита влево, а затем описанным выше способом делится на $P(x)$.
Данная реализация оперирует битами, но компьютеры обычно оперируют более крупными блоками информации.

Будем обрабатывать байт сообщения за раз, тогда алгоритм будет выглядеть следующим образом:
\lstinputlisting[caption=Побайтовый \crctt{},
    label=lst:crc32_byte,
    firstline=4,
    language=C,
    frame=single]{listings/crc32_byte.c}
В данной реализации CRC вычисляется не слева направо, а справа налево.
Это, конечно же, меняет результат, поэтому отправитель и получатель заранее должны договориться о том, в каком порядке вычисляется CRC.

Теперь зафиксируем $P(x)$.
Предыдущий подход плох тем, что содержит в себе 2 цикла: внешний, который проходит побайтово по сообщению, и внутренний, который движется по младшим 8 битам $R$.
Вариантов последних 8 бит $R$ всего $2^8 = 256$.
Мы можем заранее вычислить их все и записать в таблицу~(массив), заменив таким образом внутренний цикл.
\lstinputlisting[caption=Побайтовый \crctt{} c однобайтной таблицей,
    label=lst:crc32_byte_table,
    firstline=5,
    language=C,
    frame=single]{listings/crc32_byte_table.c}

Предыдущий способ можно сделать еще быстрее, если вычислить таблицу для большего количества байт.
% \lstinputlisting[caption=Побайтовый \crctt{} c 16-байтной таблицей,
%     label=lst:crc32_16byte,
%     firstline=5,
%     language=C,
%     frame=single]{listings/crc32_16byte.c}
Недостатком данного подхода является большой размер таблицы.
Например для алгоритма, обрабатывающего сразу 16 байт требуется таблица размером 16~Кб, которая может занять четверть или даже половину L1 кэша современного процессора.

Современные процессоры предоставляют аппаратную инструкцию для вычисления \crctt{}.
Однако ее не всегда можно применить, т.к. существует несколько наиболее распространенных многочленов $P(x)$.
Одним из часто используемых является многочлен, описанный в стандарте IEEE~802.3, $P = \text{0x04C11DB7}$\footnote{Обычно наличие слагаемого $x^{32}$ подразумевается, но не записывается, чтобы многочлен был 32-битным числом}.
Он используется при кодировании файлов PNG, в алгоритмах сжатия Gzip и Bzip2, в протоколе Ethernet и др.
Другим известным многочленом является $P = \text{0x1EDC6F41}$.
Алгоритм \crctt{} по данному многочлену обычно называют \textenglish{CRC-32C} по фамилии автора Castagnoli~\cite{231911}.
Он применяется в протоколе iSCSI, в файловых системах ext4 и Btrfs.
Набор инструкций SSE4.2 для платформы x86 предоставляет возможность вычисления только \textenglish{CRC-32C}.
Процессоры архитектуры ARM64 умеют вычислять, как IEEE~802.3 \crctt{}, так и \textenglish{CRC-32C}.

В статье~\cite{gopal2009fast} предложен алгоритм вычисления \crctt{} путем последовательной свертки больших кусков данных до размера в 128 бит.
При этом свертка может происходить параллельно, что еще больше ускоряет работу алгоритма.
После этого происходит свертка последних 128 бит, что и является результирующим CRC.
Данный алгоритм является одним из самых быстрых.
По данным~\cite{fastestCRC32} алгоритм, обрабатывающий 16 байт с помощью таблицы на платформе x86 работает с производительностью 8 бит за цикл, в то время как данная оптимизация обрабатывает 36 бит за цикл~\cite{intelPerf}.
С использованием данного подхода будет выполнена оптимизация для платформы \riscv{}.


\subsection{Расширения RISC-V}
\riscv{} обладает модульной архитектурой, что позволяет проектировать процессоры только с необходимым функционалом.
\riscv{} чип может быть 32 или 64-битным с базовым набором инструкций \textenglish{RV32I}\footnote{Полные названия расширений можно найти в таблице~\ref{tab:extensions}} и \textenglish{RV64I} соответственно.

Для добавления дополнительной фунциональности, такой как умножение и деление или операции над числами с плавающей запятой используются так называемые расширения~(англ. \textenglish{\textit{extensions}}).
Часто используемые расширения могут объединяться в группы.
Одна из них~--- G, она объединяет в себе базу I и расширения MAFDZicsr\_Zifencei.
Набор инструкций RV64GC является минимальным необходимым для запуска Linux~\cite{debwiki:riscv}.

Выбранный способ оптимизации требует наличие инструкции для умножения многочленов.
На платформе \riscv{} данные инструкции предоставляет расширение B, в котором они называются \textenglish{clmul~(carry-less multiplication)} и \textenglish{clmulh~(carry-less multiplication high)}.
В оригинальной реализации используются векторные регистры длиной 128 бит, они могут присутствовать на процессоре \riscv{} при наличие расширения V.
Однако в данном расширение отсутствуют операции clmul и clmulh\footnote{Тем не менее подобная инструкция ожидается в расширении Zvkb}, поэтому нам требуется только поддержка набора инструкций B.
\textenglish{clmul} и \textenglish{clmulh} работают на обычных регистрах, длина которых равна разрядности платформы, поэтому выполнение оптимизации возможно только на 64-битном варианте \riscv{}.

\begin{table}[h]
    \begin{english}
        \begin{center}
            \begin{tabularx}{\linewidth}{lX}
                \toprule
                Сокращение & Полное название                                            \\ \midrule
                RV32I      & Base Integer Instruction Set, 32-bit                       \\ \midrule
                RV64I      & Base Integer Instruction Set, 64-bit                       \\ \midrule
                M          & Standard Extension for Integer Multiplication and Division \\ \midrule
                A          & Standard Extension for Atomic Instructions                 \\ \midrule
                F          & Standard Extension for Single-Precision Floating-Point     \\ \midrule
                D          & Standard Extension for Double-Precision Floating-Point     \\ \midrule
                Zicsr      & Control and Status Register (CSR)                          \\ \midrule
                Zifencei   & Instruction-Fetch Fence                                    \\ \midrule
                C          & Standard Extension for Compressed Instructions             \\ \midrule
                B          & Standard Extension for Bit Manipulation                    \\ \midrule
                V          & Standard Extension for Vector Operations                   \\ \midrule
                Zvkb       & Vector Bit-manipulation used in Cryptography               \\
                \bottomrule
            \end{tabularx}
        \end{center}
    \end{english}
    \caption{Расширения \riscv}
    \label{tab:extensions}
\end{table}

\subsection{Платформы RISC-V}

Расширение B было утверждено \riscv{} \textenglish{International} в ноябре 2021 года.
По состоянию на декабрь 2022 года единственным ядром процессора, в котором есть поддержка данного расширения, является XuanTie C908.
К сожалению, ни одной платы с ним еще не представлено на рынке, поэтому требуется симулятор.
Он должен удовлетворять следующим условиям:
\begin{itemize}
    \item обладать поддержкой расширения B
    \item уметь исполнять 64-битные программы
\end{itemize}
В результате были найдены следующие симуляторы: Spike\footnote{\url{https://github.com/riscv-software-src/riscv-isa-sim}} и gem5\footnote{\url{https://www.gem5.org/}}.

\subsubsection{Spike}
Spike является функциональным симулятором \riscv{}.
Он разрабатывается \riscv{} International и обладает поддержкой всех принятых расширений архитектуры.
Тем не менее Spike не может использоваться для измерения производительности программ, т.к. не исполняет инструкции с точность до циклов. % cycle-accurate

\subsubsection{gem5}
gem5 является индустриальным стандартом для симуляции микроархитектуры с точность до циклов~\cite{DBLP:journals/corr/abs-2007-03152}.
Он позволяет тонко настраивать имеющиеся компоненты системы, такие как ядра процессора, кэш,  размер и тип оперативной памяти с помощью Python.

Именно gem5 будет использоваться в дальнейшем для оценки быстродействия алгоритма.