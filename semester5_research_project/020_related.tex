% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}
\remark{По каким-то причинам, которые скорее всего требуют ссылки}, будем рассматривать процесс компиляции только для ОС \textsc{Linux}.
\subsection{Основные определения}
\label{subsec:defs}

В данном разделе вводятся термины, необходимые для понимания работы, в соответствии с \cite{mackenzieCreatingAutomaticConfiguration2021, WelcomeClangDocumentation}.
\begin{definition}[Build]
	\textit{Build системой} называют систему, на которой производится сборка.
\end{definition}
\begin{definition}[Host]
	\textit{Host системой} называют систему, под которую производится сборка.
\end{definition}
\begin{definition}[Target]
	\textit{Target системой} называют систему, для которой будет генерироваться код, обычно используется по отношению к компиляторам.
\end{definition}

Для описания build, host и target систем используется target triple.

\begin{definition}[Target triple]
	\textit{Target triple}~--- каноническое имя системы вида \texttt{<arch><sub>-<vendor>-<sys>-<env>}, где
	\begin{itemize}
		\item \texttt{<arch>} означает архитектуру ЦП, например \texttt{x86\_64}, \texttt{riscv64} или \texttt{aarch64};
		\item \texttt{<sub>} означает подтип архитектуры ЦП, используется в основном для архитектуры \arm{};
		\item \texttt{<vendor>} указывает на производителя, например \texttt{pc}, \texttt{apple} или \texttt{oe}~(OpenEmbedded);
		\item \texttt{<sys>} обычно означает операционную систему, например \texttt{none} в случае оборудования без ОС, \texttt{linux}, \texttt{win32} или даже \texttt{cuda};
		\item \texttt{<env>} указывает на различные детали, необходимые для работы программы, такие как способ работы с числами с плавающей запятой или системную библиотеку языка \textsc{C}.
	\end{itemize}
	В случае отсутствия какого-либо компонента, он может быть опущен, либо указано слово \texttt{unknown}.
	В обоих случаях недостающие компоненты компилятор подставит сам на своё усмотрение.
\end{definition}

Современные ПК на платформах \textsc{Intel} и \textsc{AMD} имеют target triple \texttt{x86\_64-pc-linux-gnu}.
Для робототехнического контроллера ТРИК используется triple \texttt{arm-oe-linux-gnueabi}.
Для \riscv{} в качестве triple обычно используется \texttt{riscv64-linux-gnu}.

\begin{definition}[Toolchain]
	\textit{Toolchain}~--- \remark{дописать!}
\end{definition}

\begin{definition}[Sysroot]
	\textit{Sysroot}~--- минимальный образ системы для host платформы, который включает в себя необходимые зависимости для сборки и работы ПО. \remark{(хреновое определение, да)}
	Для его создания используются такие утилиты как debootstrap, buildroot, yocto, dnf. \remark{(Первый точно да, вторые два надо подумать, четвертый должен уметь в федору -- не пробовал)}
\end{definition}

\begin{definition}[Chroot]
	\textit{Chroot}~--- \remark{дописать!}
\end{definition}

\remark{(Примеры? Наверное, судя стоит сразу про компилятор писать, канадский компилятор)}

\subsection{Виды сборки}

В данном разделе описываются различные виды сборки приложений, используемые при портировании на другие архитектуры процессора.

\remark{Где-то надо сказать про вопросы портирования, типа ассемблерных вставок}

\subsubsection{Нативная сборка}

\begin{definition}[Нативная сборка]
	\textit{Нативной сборкой} будем называть способ компиляции, в случае когда build идентичен host.
\end{definition}

Данный способ является наиболее простым.
В общем случае процесс сборки на новой платформе не будет отличаться от процесса сборки на платформе, используемой разработчиком.
Кроме того, сама компиляция будет происходить достаточно быстро, а необходимые приложению зависимости будут доступны в репозиториях установленного дистрибутива \textsc{Linux}.

Тем не менее нативная компиляция имеет большой недостаток: требуется доступ к оборудованию на искомой архитектуре.

\subsubsection{Кросс-компиляция}

\begin{definition}
	\textit{Кросс-компиляция}~--- способ сборки приложения, при котором компилятор запускается на build системе, генерируя код для искомой host системы, и build $\neq$ host.
\end{definition}

Обычно для кросс-компиляции системе сборки достаточно сообщить об используемом компиляторе и, при необходимости, путь к зависимостям.

Для небольших приложений \remark{(библиотека --- приложение?)} обычно достаточно минимального набора библиотек, предоставляемого компилятором.
В этом случае дополнительные действия не требуются.

Если требуются дополнительные зависимости, то можно либо собрать их самому, либо создать sysroot. \marginpar{\remark{Странный переход}}

Первый способ достаточно трудозатратен и применяется редко.
В случае, если зависимость отсутствует в репозиториях, то допустим, что за её компиляцию и установку отвечает система сборки проекта.

На практике обычно применяется второй способ.
В этом случае системе сборки передается путь к sysroot.

К сожалению, для использования кросс-компиляции требуется поддержка как со стороны системы сборки, так и проекта.
О поддержке со стороны системам сборки более подробно рассказано в разделе \ref{subsec:build_systems}.
Некоторые проекты, например \OCaml{}, не поддерживают кросс-компиляцию вовсе.

\subsubsection{Нативная сборка в эмуляторе}

В случае если проект не поддерживает кросс-компиляцию и нет возможность получить доступ к оборудованию с целевой платформой, можно использовать эмулятор.

Ядро ОС Linux поддерживает механизм \textsc{binfmt\_misc}.
Он распознает заголовок исполняемого файла и, в случае необходимости, позволяет запускать его через программу-обертку, например Wine или \qemu{}.

В качестве эмулятора для сборки можно использовать \qemu{}.
Он может работать в двух режимах: System Emulation и User Mode Emulation.
В первом случае \qemu{} работает как виртуальная машина и эмулирует систему целиком, для этого ему требуется образ ОС, которая будет запущена внутри.
Для целей сборки такой подход слишком тяжеловесен.
Во случае же User Mode Emulation, \qemu{} исполняет программу путем трансляции машинного кода в машинный код платформы, на который он запущен, а системные вызовы \enquote{пробрасываются} наружу.
Таким образом можно запустить исполняемый файл для другой архитектуры не запуская полноценную виртуальную машину.
\remark{Здесь похоже опять нужны определения host и target...}

Далее есть два варианта действий:
\begin{enumerate}
	\item Создать sysroot со всеми необходимыми зависимостями, далее сделать chroot и собрать проект.
	\item Воспользоваться Docker контейнером, собранным для архитектуры \riscv{}\footnote{\url{https://hub.docker.com/r/riscv64/debian}}
\end{enumerate}

Данный способ хорош тем, что позволяет собирать проекты не поддерживающий кросс-компиляцию.
Однако \qemu{} работает очень медленно, поэтому сборка большого проекта занимает очень много времени.

\subsection{Системы сборки}
\label{subsec:build_systems}

В данном разделе описываются возможности кросс-компиляции в различных системах сборки.

\subsubsection{Make}

Самая простая система сборки, позволяющая \enquote{выстрелить себе в ногу}\footnote{\url{https://github.com/ocaml/ocaml/issues/4303}}.
Если Makefile правильно и аккуратно написан, то проблем скорее всего не будет.
Всё, что нужно сделать в данном случае,~--- это указать пути к инструментам сборки используемого toolchain.
% TODO: в реализацию
% При необходимости передачи sysroot, он может быть дописан к пути компилятора, например
% \begin{minted}[breaklines]{shell}
% CC="riscv64-linux-gnu-gcc --sysroot=/sysroot" make ...
% \end{minted}
% либо к аргументам компилятора, например
% \begin{minted}[breaklines]{shell}
% CFLAGS="--sysroot=/sysroot" make ...
% \end{minted}

\subsubsection{Autotools}
Autotools поддерживает кросс-компиляцию из коробки.
Для этого используется флаг \texttt{--host} у \texttt{configure}, куда передается нужный triple.

% TODO: в реализацию
% Сложности могут возникнуть с передачей sysroot компилятору.
% Тем не менее всегда можно обойти это с помощью переменных среды, например
% \begin{minted}[breaklines]{shell}
% CC="riscv64-linux-gnu-gcc --sysroot=/sysroot" ./configure --host=riscv64-linux-gnu ...
% \end{minted}
% или
% \begin{minted}[breaklines]{shell}
% CFLAGS="--sysroot=/sysroot" ./configure --host=riscv64-linux-gnu ...
% \end{minted}
% \remark{(Во-первых, я без идей надо ли например LDFLAGS, во-вторых, я не уверен, что такие подробности надо писать сюда)}

\subsubsection{CMake}
\remark{Здесь я пока сдался писать нормальный текст, ибо так и не проверил MROB}

Если не извращаться, то должно легко заработать.
Но надо проверить на MROB.

\subsubsection{QMake}

QMake~--- система сборки, изначально созданная для Qt.
Кросс-сборка поддерживается \enquote{из коробки}, хотя достаточно своеобразно.

Кросс-компиляция с помощью QMake требует ручной сборки всего Qt в кросс режиме.
Собрать Qt в частном случае, для \ci{}, несложно, однако приложения с Qt обычно динамически связываются, и в случае необходимости распространения приложения необходимо либо паковать весь Qt вместе с приложением, либо использовать конфигурацию из какого-либо дистрибутива.

Нативная или нативная в эмуляторе компиляции работают без проблем, однако в случае второй даже создание sysroot может занять достаточно много времени.

\subsubsection{Meson}

Предоставляет большие возможности кросс-компиляции, например может запускать исполняемые файлы через обертку типа Wine или \qemu{}.
Однако требуется специальный файл для описания toolchain, формат которого, к сожалению, плохо документирован: некоторые поля из документации не делаю то, что должны\footnote{Найти ссылку на issue}.

Для поиска зависимостей используется pkg-config, поэтому для корректной работы необходимо создать .personality файл для \enquote{новой} версии pkg-config~--- pkgconf~--- с правильными путями.

% TODO: в реализацию
% Выяснить эти проще всего путем выполнения chroot в sysroot и исполнения команды
% \begin{minted}[breaklines]{shell}
% pkgconf --dump-personality
% \end{minted}

\subsection{Поддержка в \ci{}}

В данном разделе описываются возможности по компиляции проектов под архитектуру \riscv{} в \ci{}.

\begin{definition}[Runner]
	\textit{Runner}~--- \remark{дописать!}
\end{definition}

\remark{
	(Нагуглил: \begin{itemize}
		\item \url{https://circleci.com/blog/managing-ci-cd-pipelines-with-arm-compute-resource-classes/} ARM
		\item \url{https://cloud-v.co/} по сути self-hosted Jenkins)
	\end{itemize}
}

\subsubsection{GitHub}

На момент написания, \GitHub{} \textsc{Actions} в своем облаке поддерживает только архитектуру \amd{}\footnote{Поддержка \arm{} намечена на начало 2024 года: \url{https://github.blog/changelog/2023-10-30-accelerate-your-ci-cd-with-arm-based-hosted-runners-in-github-actions/}}, self-hosted runner официально поддерживает как \amd{}, так и \arm{}.
\remark{(Здесь ARM видимо любой, хотя кажется актуальнее говорить только про Aarch64.)}

Сам runner написан на платформе \dotnet{}.
Со стороны рантайма \dotnet{}, поддержка \riscv{} пока что достаточно скромная\footnote{\url{https://github.com/dotnet/runtime/issues/84834}}, а наличие собственных скриптов для \textsc{MSBuild} не позволяет легко проверить сборку для неподдерживаемой платформы\footnote{Существует Pull Request с поддержкой сборки для \power{}, который так и не был принят: \url{https://github.com/actions/runner/pull/2386}}.

\remark{(Наверное если извратиться, то можно попробовать тот же \qemu{} или Box64, но привет тормоза и привет разъезжающиеся докер образы)}

\subsubsection{GitLab}

В своем облаке \gitlab{} поддерживает только архитектуру \amd{}.
Self-hosted runner написан на языке \textsc{Go} и поддерживает гораздо больше архитектур: \amd{}, \arm{}, \power{}, \textsc{z/Architecture} и \riscv{}.

% TODO: в реализацию
% Раннер гитлаба написан на Go, и существует собранный под RISC-V, но пока его можно найти только в их артефактах сборки.
% На LPi4A не проверял, т.к. наша версия имеет мало места на eMMC и докеру будет неприятно, а внешний SSD периодически отваливается.
% На VisionFive2 потребовалась пересборка ядра, спасибо вики Gentoo, что рассказали что нужно включить в конфиге ядра.
% Даже их официальная инструкция говорит о том, что требуется пересборка ядра.
% \remark{(TODO: аккуратнее прокликать menuconfig, потому что я делал это поздно ночью, мог включить что-то ненужное)}
% Кроме того, с гитлабом есть проблема: синхронизация из \GitHub{} в GitLab требует GitLab Premium, наверное можно взять self-hosted, но это большая боль как по мне.
% Есть ещё Action, который синкает репо ручками, тоже кажется костылём.

\subsubsection{Jenkins}

\remark{Здесь пока не очень}

\jenkins{} сам по себе является self-hosted \ci{} системой.
Он написан на \java{}, поддержка \riscv{} в которой появилась ещё в 2022 году\footnote{\url{https://wiki.openjdk.org/display/RISCVPort}}.

% TODO: в реализацию
% Java, которая умеет в риск, всё супер. В дебиановском репе пакеты под архитектуру All. На VisionFive2 по умолчанию старые репозитории, и он не стартует. Если вписать http://ftp.ru.debian.org/debian/ и установить более новую Java, то всё становится хорошо
% \begin{minted}{shell}
% # update-alternatives --set iptables /usr/sbin/iptables-legacy
% # update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
% \end{minted}

% docker-pipelines~--- плагин чтобы использовать docker
% \begin{minted}{shell}
% # usermod -aG docker jenkins
% \end{minted}

% И серверу и агенту на одной платке тесно.
% Надо разносить, но наверное для компании, если у них уже Jenkins, норм.

% Надо ещё проверить как поллить ГХ на тему коммитов
