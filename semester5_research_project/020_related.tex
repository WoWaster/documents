% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

В тексте работы рассматривается процесс компиляции только для ОС \linux{}.
Вопросы переноса приложений, такие как адаптация ассемблерных вставок, не затрагиваются.

\subsection{Основные определения}
\label{subsec:defs}

В данном разделе вводятся термины, необходимые для понимания работы, в соответствии с \cite{mackenzieCreatingAutomaticConfiguration2021, WelcomeClangDocumentation}.
\begin{definition}[Build]
	\textit{Build системой} называют систему, на которой производится сборка.
\end{definition}
\begin{definition}[Host]
	\textit{Host системой} называют систему, под которую производится сборка.
\end{definition}
\begin{definition}[Target]
	В отношении компиляторов так же употребляется термин \textit{target система}, который обозначает систему, для которой будет генерироваться машинный код.
\end{definition}

Для указания build, host и target систем используют стандартный способ именования, называемый target triple.

\begin{definition}[Target triple]
	\textit{Target triple}~--- каноническое имя системы вида \texttt{<arch><sub>-<vendor>-<sys>-<env>}, где
	\begin{itemize}
		\item \texttt{<arch>} означает архитектуру ЦП, например \texttt{x86\_64}, \texttt{riscv64} или \texttt{aarch64};
		\item \texttt{<sub>} означает подтип архитектуры ЦП, используется в основном для архитектуры \arm{};
		\item \texttt{<vendor>} указывает на производителя, например \texttt{pc}, \texttt{apple} или \texttt{oe}~(OpenEmbedded);
		\item \texttt{<sys>} обычно означает операционную систему, например \texttt{none} в случае оборудования без ОС, \texttt{linux}, \texttt{win32} или даже \texttt{cuda};
		\item \texttt{<env>} указывает на различные детали, необходимые для работы программы, такие как наличие аппаратной поддержки чисел с плавающей запятой или системную библиотеку языка \textsc{C}.
	\end{itemize}
	В случае отсутствия какого-либо компонента, он может быть опущен, либо указано слово \texttt{unknown}.
	В обоих случаях недостающие компоненты компилятор подставит сам на своё усмотрение.
\end{definition}

Современные ПК на платформах \textsc{Intel} и \textsc{AMD} имеют target triple \texttt{x86\_64-pc-linux-gnu}.
Для робототехнического контроллера ТРИК используется triple \texttt{arm-oe-linux-gnueabi}.
Для \riscv{} в качестве triple обычно используется \texttt{riscv64-linux-gnu}.

\begin{definition}[Sysroot]
	\textit{Sysroot}~--- минимальный образ системы для host платформы, который включает в себя необходимые зависимости для сборки и работы ПО.
	Для его создания используются такие утилиты как \debootstrap{}, \textsc{DNF}, \textsc{Buildroot}, \textsc{Yocto Project}.
	Первые два позволяют создавать sysroot известных дистрибутивов, таких как \debian{} и \textsc{Fedora}.
	Последние же позволяют создать собственный специализированный дистрибутив \linux{}.
\end{definition}

\begin{definition}[Toolchain]
	Термином \textit{toolchain} будем называть набор инструментов, необходимых для компиляции програмы.
	Обычно он состоит из компилятора, компоновщика, отладчика и необходимых для их работы утилит.
	Кроме того, toolchain часто содержит sysroot своей target платформы.
\end{definition}

\begin{definition}[Нативная сборка]
	\textit{Нативной сборкой} будем называть способ компиляции, в случае когда build идентичен host.
\end{definition}

\begin{definition}[Кросс-компиляция]
	\textit{Кросс-компиляция}~--- способ сборки приложения, при котором компилятор запускается на build системе, генерируя код для искомой host системы, и build $\neq$ host.
	Требует специальный toolchain.
\end{definition}

Разберем несколько примеров.
Если мы производим нативную сборку обычного приложения, например, для платформы \amd{}, то build $=$ host $=$ \texttt{x86\_64-pc-linux-gnu}.
При кросс-сборке на платформе \amd{} для платформы \riscv{} получим build $=$ \texttt{x86\_64-pc-linux-gnu} и host $=$ \texttt{riscv64-linux-gnu}.

Для сборки компиляторов используется определение target системы.
Так, для нативного компилятора для \amd{} используется build $=$ host $=$ target $=$ \texttt{x86\_64-pc-linux-gnu}.
Для кросс-компилятора для \riscv{} будут использованы build $=$ host $=$ \texttt{x86\_64-pc-linux-gnu} и target $=$ \texttt{riscv64-linux-gnu}.
Существует также так называемая \enquote{канадская сборка}, в этом случае build $\neq$ host $\neq$ target.
Например для сборки на \amd{} кросс-компилятора, который будет работать на \textsc{Mac OS} на процессоре \amd{} и генерировать код для \riscv{}, будут использованы следующие определения: build = \texttt{x86\_64-pc-linux-gnu}, host = \texttt{x86\_64-apple-darwin} и target = \texttt{riscv64-linux-gnu}.

\subsection{Виды сборки}

В данном разделе описываются различные виды сборки приложений, используемые при переносе на другие архитектуры процессора.

\subsubsection{Нативная сборка}

Данный способ является наиболее простым.
В общем случае процесс сборки на новой платформе не будет отличаться от процесса сборки на платформе, используемой разработчиком.
Кроме того, сама компиляция будет происходить достаточно быстро, а необходимые приложению зависимости будут доступны в репозиториях установленного дистрибутива \linux{}.

Тем не менее нативная компиляция имеет большой недостаток: требуется доступ к оборудованию на искомой архитектуре.

\subsubsection{Кросс-компиляция}

Для кросс-компиляции системе сборки нужно сообщить об используемом компиляторе и, при необходимости, путь к зависимостям.

Для небольших программных продуктов обычно достаточно минимального набора библиотек, предоставляемого компилятором.
В этом случае дополнительные действия не требуются.

Если требуются дополнительные зависимости, то можно либо создать sysroot, либо собрать их самому.

Чаще всего создают sysroot, так как это более простой и удобный способ.
В этом случае системе сборки передается путь к нему.
Собирать зависимости в ручную достаточно сложно и долго.
Тем не менее может быть необходимо, если, например, нужная зависимость отсутствует в репозиториях.

Далее будем считать, что все необходимые зависимости доступны в репозиториях.
В ином случае подразумевается, что за их компиляцию и установку отвечает система сборки проекта.

К сожалению, для использования кросс-компиляции требуется поддержка как со стороны системы сборки, так и проекта.
О поддержке со стороны системам сборки более подробно рассказано в разделе \ref{subsec:build_systems}.
Некоторые проекты, например \OCaml{}, не поддерживают кросс-компиляцию вовсе.

\subsubsection{Нативная сборка в эмуляторе}

В случае если проект не поддерживает кросс-компиляцию и нет возможность получить доступ к оборудованию с целевой платформой, можно использовать эмулятор.

Ядро ОС Linux поддерживает механизм \textsc{binfmt\_misc}.
Он распознает заголовок исполняемого файла и, в случае необходимости, позволяет запускать его через программу-обертку, например \textsc{Wine} или \qemu{}.

В качестве эмулятора для сборки можно использовать \qemu{}.
Он может работать в двух режимах: System Emulation и User Mode Emulation.
В первом случае \qemu{} работает как виртуальная машина и эмулирует систему целиком, для этого ему требуется образ ОС, которая будет запущена внутри.
Для целей сборки такой подход слишком тяжеловесен.
При использовании User Mode Emulation, \qemu{} исполняет программу путем трансляции машинного кода, в который скомпилирована программа, в машинный код платформы, на который он запущен, а системные вызовы \enquote{пробрасываются} наружу.
Таким образом можно запустить исполняемый файл для другой архитектуры не запуская полноценную виртуальную машину.
А \textsc{binfmt\_misc} в данном случае позволяет запускать исполняемые файлы без необходимости оборачивать каждый вызов явно.

Далее есть два варианта действий:
\begin{enumerate}
	\item Создать sysroot со всеми необходимыми зависимостями и выполнить chroot~(от англ. \textit{change root}~--- команда, позволяющая сменить текущий корень системы, тем самым можно перейти в другую систему).
	\item Воспользоваться \docker{} контейнером, собранным для архитектуры \riscv{}\footnote{Например, \url{https://hub.docker.com/r/riscv64/debian}}.
\end{enumerate}

Данный способ хорош тем, что позволяет собирать проекты не поддерживающие кросс-компиляцию.
Однако \qemu{} работает очень медленно, поэтому сборка большого проекта занимает много времени.

\subsection{Системы сборки}
\label{subsec:build_systems}

В данном разделе описываются возможности кросс-компиляции в различных системах сборки.

\subsubsection{Make}

Самая простая система сборки, позволяющая \enquote{выстрелить себе в ногу}\footnote{\url{https://github.com/ocaml/ocaml/issues/4303}}.
Если Makefile правильно и аккуратно написан, то проблем скорее всего не будет.
Всё, что нужно сделать в данном случае,~--- это указать пути к инструментам сборки используемого toolchain.

\subsubsection{Autotools}

\autotools{} поддерживает кросс-компиляцию из коробки.
Для этого используется флаг \texttt{--host} у \texttt{configure}, куда передается нужный triple.
Тем не менее могут быть сложности с передачей sysroot.

\subsubsection{CMake}

\cmake{} поддерживает кросс-компиляцию из коробки.
Для этого он использует хорошо документированные toolchain файлы.

\subsubsection{QMake}

\qmake{}~--- система сборки, изначально созданная для \qt{}.
Кросс-сборка поддерживается из коробки, хотя достаточно своеобразно.

Кросс-компиляция с помощью \qmake{} требует ручной сборки всего \qt{} в кросс режиме.
Собрать \qt{} в частном случае, для \ci{}, несложно, однако приложения с \qt{} обычно динамически связываются, и в случае необходимости распространения приложения необходимо либо паковать весь \qt{} вместе с приложением, либо использовать конфигурацию из какого-либо дистрибутива.

Нативная или нативная в эмуляторе компиляции работают без проблем, однако в случае второй даже создание sysroot может занять достаточно много времени.

\subsubsection{Meson}

Предоставляет большие возможности кросс-компиляции, например может запускать исполняемые файлы через обертку типа \textsc{Wine} или \qemu{}.
Однако требуется специальный файл для описания toolchain, формат которого, к сожалению, плохо документирован: некоторые поля из документации не делаю то, что должны.

Для поиска зависимостей используется pkg-config, поэтому для корректной работы необходимо создать .personality файл для \enquote{новой} версии pkg-config~--- pkgconf~--- с правильными путями.

\subsection{Поддержка в \ci{}}

В данном разделе описываются возможности по настройки \ci{} на архитектурах, отличных от \amd{}.

\begin{definition}[Runner]
	Под термином \textit{runner} будем понимать приложение, предоставляемое \ci{} системой, ответственное за запуск написанных пользователей сценариев работы \ci{}.
	Runner может запускаться как в облаке \ci{} сервиса, так и локально пользователем, в таком случае он будет называться \textit{self-hosted runner}.
\end{definition}

\subsubsection{GitHub}

На момент написания, \GitHub{} \textsc{Actions} в своем облаке поддерживает только архитектуру \amd{}\footnote{Поддержка \arm{} намечена на начало 2024 года: \url{https://github.blog/changelog/2023-10-30-accelerate-your-ci-cd-with-arm-based-hosted-runners-in-github-actions/}}, self-hosted runner официально поддерживает как \amd{}, так и \arm{}.

Сам runner написан на платформе \dotnet{}.
Со стороны рантайма \dotnet{}, поддержка \riscv{} пока что достаточно скромная\footnote{\url{https://github.com/dotnet/runtime/issues/84834}}, а наличие собственных скриптов для \textsc{MSBuild} не позволяет легко проверить сборку для неподдерживаемой платформы\footnote{Существует Pull Request с поддержкой сборки для \power{}, который так и не был принят: \url{https://github.com/actions/runner/pull/2386}}.

\subsubsection{GitLab}

В своем облаке \gitlab{} поддерживает только архитектуру \amd{}.
Self-hosted runner написан на языке \textsc{Go} и поддерживает гораздо больше архитектур: \amd{}, \arm{}, \power{}, \textsc{z/Architecture} и \riscv{}.

\subsubsection{Jenkins}

\jenkins{} сам по себе является self-hosted \ci{} системой.
Он написан на \java{}, поддержка \riscv{} в которой появилась ещё в 2022 году\footnote{\url{https://wiki.openjdk.org/display/RISCVPort}}, поэтому всё работает из коробки.
