% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

Всегда будет рассматривать компиляцию только для ОС Linux.

Для начала введём некоторые термины, использующиеся при кросс-компиляции (в соответствии с \cite{CrossCompilationAutomake}):
\begin{itemize}
	\item Build~--- система, на которой производится сборка;
	\item Host~--- система, под которую производится сборка;
	\item Target~--- в случае компиляторов, система, для которой будет генерироваться код.
\end{itemize}

\remark{triplet, toolchain}

\remark{(Примеры?)}

Для небольших приложений \remark{(библиотека --- приложение?)} обычно достаточно минимального набора библиотек, предоставляемого компилятором.

В случае же если требуются дополнительные зависимости, то можно либо собрать их самому, либо создать sysroot какого-нибудь дистрибутива.

Первый способ обычно достаточно трудозатратен и обычно не используется.
В случае, если зависимость отсутствует в репозиториях, то допустим, что за её компиляцию и установку отвечает система сборки проекта.

Поэтому обычно используется второй способ.
Sysroot~--- минимальный образ системы для host платформы, который включает в себя необходимые зависимости для сборки и работы ПО. \remark{(хреновое определение, да)}
Для его создания используются такие утилиты как debootstrap, buildroot, yocto, dnf. \remark{(Первый точно да, вторые два надо подумать, четвертый должен уметь в федору -- не пробовал)}

\subsection{Виды сборки}

\subsubsection{Нативная сборка}

Самый обычный вид сборки, когда build = host.
В данном случае от разработчика требуется минимум усилий для сборки своего проекта, так как среда внешне не отличается от привычной.

Сам процесс компиляции происходит довольно быстро, а зависимости устанавливаются из системных репозиториев.
Тем не менее у данного подхода есть и недостатки, например необходимость покупки устройств на платформе \riscv{}.
\remark{(По идее может быть архитектурно специфичный код, но ввязать пока не получается и это по идее больше вопросы портирования)}

\subsubsection{Кросс-компиляция}

Способ компиляции, при котором build $\neq$ host.
Требует использования компилятора, target которого есть ожидаемый host.

Для этого системе сборки необходимо сообщить об используемом компиляторе, а также, в случае необходимости, о пути к sysroot с зависимостями для сборки.

Основная проблема данного метода: требуется поддержка как со стороны системы сборки, так и проекта.
О поддержке кросс-компиляции различными системами сборки более подробно рассказано в \ref{subsec:build_systems}.
Некоторые проекты, например \OCaml{}, не поддерживают кросс-компиляцию вовсе.

\subsubsection{Нативная сборка в эмуляторе}

В случае если проект не поддерживает кросс-компиляцию и нет возможность получить доступ к оборудованию с целевой платформой, можно использовать эмулятор.

Ядро ОС Linux поддерживает механизм \textsc{binfmt\_misc}.
Он распознает заголовок исполняемого файла и в случае необходимости позволяет запускать его через программу-обертку, например Wine или \qemu{}.

В качестве эмулятора для сборки можно использовать \qemu{}.
Он может работать в двух режимах: System Emulation и User Mode Emulation.
В первом случае \qemu{} работает как виртуальная машина и эмулирует систему целиком, для этого ему требуется образ ОС, которая будет запущена внутри.
Для целей сборки такой подход слишком тяжеловесен.
Во случае же User Mode Emulation, \qemu{} исполняет программу путем трансляции машинного кода в машинный код платформы, на который он запущен, а системные вызовы \enquote{пробрасываются} наружу.
Таким образом можно запустить исполняемый файл для другой архитектуры не запуская полноценную виртуальную машину.
\remark{Здесь похоже опять нужны определения host и target...}

Далее есть два варианта действий:
\begin{enumerate}
	\item Создать sysroot со всеми необходимыми зависимостями, далее сделать chroot и собрать проект.
	\item Воспользоваться Docker контейнером, собранным для архитектуры \riscv{}\footnote{\url{https://hub.docker.com/r/riscv64/debian}}
\end{enumerate}

Данный способ хорош тем, что позволяет собирать проекты не поддерживающий кросс-компиляцию.
Однако \qemu{} работает очень медленно, поэтому сборка большого проекта занимает очень много времени.

\subsection{Системы сборки}
\label{subsec:build_systems}

\subsubsection{Make}

Самая простая система сборки, позволяющая \enquote{выстрелить себе в ногу}\footnote{\url{https://github.com/ocaml/ocaml/issues/4303}}.
Если Makefile правильно и аккуратно написан, то проблем скорее всего не будет.
Всё, что нужно сделать в данном случае,~--- это указать правильные переменные CC и CXX, и при необходимости дописать туда путь к sysroot.

\subsubsection{Autotools}
Autotools поддерживает кросс-компиляцию из коробки.
Для этого используется флаг \texttt{--host} у \texttt{configure}, куда передается нужный triplet.

Сложности могут возникнуть с передачей sysroot компилятору.
Тем не менее всегда можно обойти это с помощью переменных среды, например
\begin{minted}[breaklines]{shell}
CC="riscv64-linux-gnu-gcc --sysroot=/sysroot" ./configure --host=riscv64-linux-gnu ...
\end{minted}
или
\begin{minted}[breaklines]{shell}
CFLAGS="--sysroot=/sysroot" ./configure --host=riscv64-linux-gnu ...
\end{minted}
\remark{(Во-первых, я без идей надо ли например LDFLAGS, во-вторых, я не уверен, что такие подробности надо писать сюда)}

\subsubsection{CMake}
\remark{Здесь я пока сдался писать нормальный текст, ибо так и не проверил MROB}

Если не извращаться, то должно легко заработать.
Но надо проверить на MROB.

\subsubsection{QMake}

\remark{Здесь и далее я пока сдался писать нормальный текст}

QMake~--- система сборки, изначально созданная для Qt.

Кросс-компиляция с помощью QMake требует ручной сборки всего Qt в кросс режиме.
Собрать Qt в частном случае, для CI, несложно, однако приложения с Qt обычно динамически связываются, и в случае необходимости распространения приложения необходимо либо паковать весь Qt вместе с приложением, либо брать параметры конфигурации из какого-либо дистрибутива.

Нативная или нативная в эмуляторе компиляции работают без проблем, однако в случае второй даже создание sysroot может занять около часа.

\subsubsection{Meson}

Для кросс-компиляции требует специальный toolchain файл, формат которого, к сожалению, плохо документирован.
Для поиска зависимостей используется pkg-config, поэтому для корректной работы необходимо создать .personality файл для \enquote{новой} версии pkg-config~--- pkgconf~--- с правильными путями, выяснить которые проще сделав chroot в sysroot.

\subsection{Поддержка в CI}

Хостинги для проектов, в частности GitHub и GitLab, предоставляют собственные сервисы для настройки CI, тем не менее не имеют собственных runner'ов на архитектуре \riscv{}.

\remark{
	(Вообще нагуглил: \begin{itemize}
		\item \url{https://github.blog/changelog/2023-10-30-accelerate-your-ci-cd-with-arm-based-hosted-runners-in-github-actions/}
		\item \url{https://circleci.com/blog/managing-ci-cd-pipelines-with-arm-compute-resource-classes/}
		\item \url{https://cloud-v.co/}
	\end{itemize}
	первые два только про арм, но уже хоть что-то.
	Третий по сути тоже self-hosted Jenkins)
}

Но есть возможность сделать self-hosted runner.

\subsubsection{GitHub}

Приложение от GitHub написано в основном на .NET.
На данный момент .NET поддерживает \riscv{} базово.
Кроме того, GH использует скрипты для MSBuild для сборки переносимого приложения.
Есть draft PR\footnote{
	\url{https://github.com/actions/runner/pull/2386}
} для ppc64-le, но выглядит страшно.
Кроме того, даже сейчас, в альфе .NET9, у них нет нормального GC.
\remark{(Наверное если извратиться, то можно попробовать тот же \qemu{} или Box64, но привет тормоза и привет разъезжающиеся докер образы)}

\subsubsection{GitLab}

Раннер гитлаба написан на Go, и существует собранный под RISC-V, но пока его можно найти только в их артефактах сборки.
На LPi4A не проверял, т.к. наша версия имеет мало места на eMMC и докеру будет неприятно, а внешний SSD периодически отваливается.
На VisionFive2 потребовалась пересборка ядра, спасибо вики Gentoo, что рассказали что нужно включить в конфиге ядра.
Даже их официальная инструкция говорит о том, что требуется пересборка ядра.
\remark{(TODO: аккуратнее прокликать menuconfig, потому что я делал это поздно ночью, мог включить что-то ненужное)}
Кроме того, с гитлабом есть проблема: синхронизация из GitHub в GitLab требует GitLab Premium, наверное можно взять self-hosted, но это большая боль как по мне.
Есть ещё Action, который синкает репо ручками, тоже кажется костылём.

\subsubsection{Jenkins}
Java, которая умеет в риск, всё супер. В дебиановском репе пакеты под архитектуру All. На VisionFive2 по умолчанию старые репозитории, и он не стартует. Если вписать http://ftp.ru.debian.org/debian/ и установить более новую Java, то всё становится хорошо
\begin{minted}{shell}
# update-alternatives --set iptables /usr/sbin/iptables-legacy
# update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
\end{minted}

docker-pipelines~--- плагин чтобы использовать docker
\begin{minted}{shell}
# usermod -aG docker jenkins
\end{minted}

И серверу и агенту на одной платке тесно.
Надо разносить, но наверное для компании, если у них уже Jenkins, норм.

Надо ещё проверить как поллить ГХ на тему коммитов
