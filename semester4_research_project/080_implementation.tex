% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}

Библиотека содержит в себе четыре алгоритма хеширования: \xxh{32}, \xxh{64}, \xxh{3}, \xxh{128}.
Первые два из них не поддаются оптимизации с помощью векторных операций, поэтому интерес представляют только последние.
Внутри они используют функции \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc}.
Именно эти функции могут использовать векторные возможности процессора: в библиотеке уже имеется поддержка \textsc{SSE2, AVX512, NEON} и других.
Сама библиотека написана на языке \textsc{C}, а для оптимизации применяются intrinsic функции.

Уже существующие реализации оперируют компонентами вектора размером в 64 бита, в терминологии \riscv{} это называется \textsc{SEW\footnote{Selected Element Width}}.
А длина вектора разнится от 128 бит до 512 бит, в терминологии \riscv{}~--- \textsc{VL\footnote{Vector Length}}.

По спецификации векторного расширения \riscv{}, минимальный \vl{} равен 128 битам, также должна присутствовать поддержка \sew{} равного 64 битам.
К сожалению, на момент написания данной работы в продаже можно было найти лишь устройства на чипе \textsc{Allwinner D1}, в котором отсутствует поддержка 64-битных элементов вектора, поэтому была предпринята попытка использовать \sew{} в 32 бита из-за чего потребовалась некоторое количество ухищрений.

В качестве эталонной реализации был выбран вариант для набора команд \textsc{SSE2}, т.~к. целевой процессор имеет \vl{} в 128 бит, как и \textsc{SSE2}.

%???: нужны ли куски кода? Они не очень хорошо влезают в ширину даже :)

% Рассказать про то, что хотим умножить два 32-битных числа и расширить до 64 битов
% НО мы не умеем в SEW=64, поэтому танцы с бубном:
% умножаем отдельно low и high, двигаем high влево, мерджим high и low части
Одной из первых проблем стала операция умножения.
В алгоритме требуется перемножить 2 вектора, используя только младшие 32 бита каждого элемента, в результате чего получаются 64-битные числа.
При \sew{} в 32 бита необходимо перемножить между собой нулевой и второй элементы каждого вектора.
Для совершения данной операции пришлось использовать отдельные инструкции для вычисления младших и старших битов произведения, затем сдвигать старшие биты в первый и третий элемент вектора, а после объединять их по маске, таким образом, чтобы в нулевой и второй элемент попали младшие биты произведения, а в первый и третий старшие соответственно.
\begin{listing}
	\caption{Пример для умножения, выдранный из библиотеки}
	\inputminted[breaklines, frame=single]{c}{figures/mul_example.c}
\end{listing}
\begin{listing}
	\caption{Пример для умножения, попытка использовать перегрузки}
	\inputminted[breaklines, frame=single]{c}{figures/mul_example1.c}
\end{listing}
\begin{listing}
	\caption{Пример для умножения, попытка использовать перегрузки и комментарии}
	\inputminted[breaklines, frame=single]{c}{figures/mul_example2.c}
\end{listing}

% Сложение, тварь такая, в смысле страдания с переносом
% узнаем где случается перенос, затем оставляем битики переноса только у 0 и 2 элемента,
% затем выполняем сложение без мыслей о переносе, затем меняем местами (0 и 1) и (2 и 3),
% после этого делаем сложение с переносом с нулевым вектором и только после этого возвращаем элементы на свои места
Кроме того, сложение тоже требует модификации: необходимо сохранить бит переноса, т.~к. мы складываем 64-битные числа, представленные как пары 32-битных.
\riscv{} имеет инструкцию, которая по паре векторов заполняет битовую маску: если при сложении необходим перенос, соответствующий бит становится единицей.
Однако команды для сдвига маски не существует, поэтому используется такая последовательность команд: сначала вычисляется маска переноса, затем... % хватит
% \lstinputlisting[caption={222}, language=C, frame=single, breaklines]{figures/add_example.c}

% RVV0.7.1 сука
% Нет команды загрузки масок, поэтому генерируем маски командой set if equal to
% Нет vmadc_vv, только vmadc_vvm, поэтому требуется создать пустую маску, БЛАГО хоть для этого есть инструкция
% Нет перегрузки интринсиков
\textsc{Allwinner D1} поддерживает векторное расширение \riscv{} экспериментальной версии 0.7.1, которая более не имеет официальной поддержки, а единственный компилятор со встроенной поддержкой поддерживается компанией \textsc{Alibaba} на основе \textsc{GCC 10}.
Актуальная и ратифицированная версия расширения~--- 1.0, она поддерживается современными версия \textsc{LLVM} и \textsc{GCC}.
К сожалению, в версия 0.7.1 гораздо менее доработана, нежели версия 1.0.

Одной из проблем версии 0.7.1, является отсутствие операции загрузки маски из памяти.
Для обхода этого ограничения используется команда \texttt{vmseq.vx}, она принимает на вход вектор и число, и если элемент вектора равен заданному числу, то бит в маске устанавливается в единицу.

Операция вычисления битов переноса при сложении в версии 0.7.1 сделана таким образом, что ей всегда требуется маска, даже если это первое вычисление и поэтому необходимо создавать маску из нулей для корректной работы.

Современные версии \textsc{LLVM} и \textsc{GCC} поддерживают \enquote{перегрузку} интринсик функций, что делает код гораздо более читаем~--- строго типы нужно указывать малому количеству операции, например загрузке и выгрузке векторов в память.
К сожалению, в компиляторе от \textsc{Alibaba} данная возможность отсутствует.
\begin{listing}
	\caption{Сравнение перегруженных и не перегруженных функций}
	\inputminted[breaklines, frame=single]{c}{figures/generic.c}
\end{listing}

% Alignment!!
Спецификация векторных расширений \riscv{} не определяет корректное поведение при загрузке данных из памяти по невыровненному адресу.
Так например в функции \texttt{XXH3\_accumulate}, два из трех указателей, принимаемых на вход, являются невыровненными.
К счастью, эту проблему легко обойти: достаточно загружать данные, как если бы вектор был из 8-битных элементов, а затем интерпретировать его как вектор нужной размерности.
\begin{listing}
	\caption{Загрузка по невыровненному адресу}
	\begin{minted}[breaklines, frame=single]{c}
vuint32m1_t key_vec = vreinterpret_v_u8m1_u32m1(vle8_v_u8m1((uint8_t*)(xsecret + VL * i), VL * 4));
	\end{minted}
\end{listing}
