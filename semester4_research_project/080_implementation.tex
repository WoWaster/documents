% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}

Библиотека содержит в себе четыре алгоритма хеширования: \xxh{32}, \xxh{64}, \xxh{3}, \xxh{128}.
Первые два из них не поддаются оптимизации с помощью векторных операций, поэтому интерес представляют только последние.
Внутри они используют функции \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc}.
Именно эти функции могут использовать векторные возможности процессора: в библиотеке уже имеется поддержка \textsc{SSE2, AVX512, NEON} и других.
Сама библиотека написана на языке \textsc{C}, а для оптимизации применяются intrinsic функции.

Уже существующие реализации оперируют компонентами вектора размером в 64 бита, в терминологии \riscv{} это называется Selected Element Width~(\sew{}).
А длина вектора разнится от 128 бит до 512 бит, в терминологии \riscv{}~--- Vector Length~(\vl{}).

По спецификации векторного расширения \riscv{}, минимальный \vl{} равен 128 битам, также должна присутствовать поддержка \sew{} равного 64 битам.
К сожалению, на момент написания данной работы в продаже можно было найти лишь устройства на чипе \textsc{Allwinner D1}, в котором отсутствует поддержка 64-битных элементов вектора, поэтому была предпринята попытка использовать \sew{} в 32 бита из-за чего потребовалась некоторое количество ухищрений.

В качестве эталонной реализации был выбран вариант для набора команд \textsc{SSE2}, т.~к. целевой процессор имеет \vl{} в 128 бит, как и \textsc{SSE2}.

Одной из первых проблем стала операция умножения.
В алгоритме требуется перемножить 2 вектора, используя только младшие 32 бита каждого элемента, в результате чего получаются 64-битные числа.
При \sew{} в 32 бита необходимо перемножить между собой нулевой и второй элементы каждого вектора.
Для совершения данной операции пришлось использовать отдельные инструкции для вычисления младших и старших битов произведения, затем сдвигать старшие биты в первый и третий элемент вектора, а после объединять их по маске, таким образом, чтобы в нулевой и второй элемент попали младшие биты произведения, а в первый и третий старшие соответственно.
Данную операцию иллюстрирует листинг \ref{mint:mul}.
\begin{listing}
	\caption{Умножение с ручным расширением до 64 бит}
	\label{mint:mul}
	\inputminted[breaklines, frame=single]{c}{figures/mul.c}
\end{listing}

Кроме того, сложение тоже требует модификации: необходимо сохранить бит переноса, т.~к. мы складываем 64-битные числа, представленные как пары 32-битных.
\riscv{} имеет инструкцию, которая по паре векторов заполняет битовую маску: если при сложении необходим перенос, соответствующий бит становится единицей.
Однако команды для сдвига маски не существует, поэтому используется такая последовательность команд: сначала вычисляется маска переноса, затем, с помощью операции И в маске оставляются только биты на нулевом и втором местах, после этого выполняется обычное сложение.
Затем чтобы прибавить бит переноса, элементы вектора попарно переставляются местами, производится прибавление переноса, а затем возвращение элементов на свои места.
Эту операцию иллюстрирует листинг \ref{mint:add}.
\begin{listing}
	\caption{Сложение с переносом}
	\label{mint:add}
	\inputminted[breaklines, frame=single]{c}{figures/add.c}
\end{listing}

\textsc{Allwinner D1} поддерживает векторное расширение \riscv{} экспериментальной версии 0.7.1, которая более не имеет официальной поддержки, а единственный компилятор со встроенной поддержкой поддерживается компанией \textsc{Alibaba} на основе \textsc{GCC 10}.
Актуальная и ратифицированная версия расширения~--- 1.0, она поддерживается современными версия \textsc{LLVM} и \textsc{GCC}.
К сожалению, в версия 0.7.1 гораздо менее доработана, нежели версия 1.0.

Одной из проблем версии 0.7.1, является отсутствие операции загрузки маски из памяти.
Для обхода этого ограничения используется команда \texttt{vmseq.vx}, она принимает на вход вектор и число, и если элемент вектора равен заданному числу, то бит в маске устанавливается в единицу.

Операция вычисления битов переноса при сложении в версии 0.7.1 сделана таким образом, что ей всегда требуется маска, даже если это первое вычисление и поэтому необходимо создавать маску из нулей для корректной работы.

Современные версии \textsc{LLVM} и \textsc{GCC} поддерживают \enquote{перегрузку} интринсик функций, что делает код гораздо более читаем~--- строго типы нужно указывать малому количеству операции, например загрузке и выгрузке векторов в память.
К сожалению, в компиляторе от \textsc{Alibaba} данная возможность отсутствует.
\begin{listing}
	\caption{Сравнение перегруженных и не перегруженных функций}
	\inputminted[breaklines, frame=single]{c}{figures/generic.c}
\end{listing}

Спецификация векторных расширений \riscv{} не определяет корректное поведение при загрузке данных из памяти по невыровненному адресу.
Так например в функции \texttt{XXH3\_accumulate}, два из трех указателей, принимаемых на вход, являются невыровненными.
К счастью, эту проблему легко обойти: достаточно загружать данные, как если бы вектор был из 8-битных элементов, а затем интерпретировать его как вектор нужной размерности.
\begin{listing}
	\caption{Загрузка по невыровненному адресу}
	\begin{minted}[breaklines, frame=single]{c}
vuint32m1_t key_vec = vreinterpret_v_u8m1_u32m1(vle8_v_u8m1((uint8_t*)(xsecret + VL * i), VL * 4));
	\end{minted}
\end{listing}
