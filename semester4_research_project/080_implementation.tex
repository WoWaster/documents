% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}
Как было сказано выше, интерес для оптимизации представляют фукнции: \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc}.
В библиотеке уже имеются их варианты с использованием таких векторных расширений, как \textsc{SSE2, AVX512, NEON} и других.
Сама библиотека написана на языке \textsc{C}, а для оптимизации применяются intrinsic функции.

Уже существующие реализации оперируют компонентами вектора размером в 64 бита, что в терминологии \riscv{} называется Selected Element Width~(\sew{}).
А длина вектора разнится от 128 бит до 512 бит, в терминологии \riscv{}~--- Vector Length~(\vl{}).

В качестве эталонной реализации был выбран вариант для набора команд \textsc{SSE2}, т.~к. целевой процессор имеет \vl{} в 128 бит, как и \textsc{SSE2}.

По спецификации векторного расширения \riscv{}, минимальный \vl{} равен 128 битам, также должна присутствовать поддержка \sew{} равного 64 битам.
К сожалению, в устройствах на чипе \textsc{Allwinner D1}, отсутствует поддержка 64-битных элементов вектора, поэтому была предпринята попытка использовать \sew{} в 32 бита из-за чего потребовалось некоторое количество ухищрений, о которых будет рассказано далее.

\subsection{Умножение с ручным расширением}
Одной из первых проблем стала операция умножения.
В алгоритме требуется перемножить 2 вектора, используя только младшие 32 бита каждого элемента, в результате чего получаются 64-битные числа.
При \sew{} в 32 бита необходимо перемножить между собой нулевой и второй элементы каждого вектора.
Для совершения данной операции необходимо использовать отдельные инструкции для вычисления младших и старших битов произведения, затем сдвигать старшие биты в первый и третий элемент вектора, а после объединять их по маске, таким образом, чтобы в нулевой и второй элемент попали младшие биты произведения, а в первый и третий старшие соответственно.
Данную операцию иллюстрирует листинг \ref{mint:mul}.
\begin{listing}
	\caption{Умножение с ручным расширением до 64 бит}
	\label{mint:mul}
	\inputminted[breaklines, frame=single]{c}{figures/mul.c}
\end{listing}

\subsection{Сложение с переносом}
Сложение тоже требует модификации: необходимо сохранить бит переноса, т.~к. мы складываем 64-битные числа, представленные как пары 32-битных.
\riscv{} имеет инструкцию, которая по паре векторов заполняет битовую маску: если при сложении необходим перенос, соответствующий бит становится единицей.
Однако команды для сдвига маски не существует, поэтому используется такая последовательность команд: сначала вычисляется маска переноса, затем, с помощью операции И, в маске оставляются только биты на нулевом и втором местах, после этого выполняется обычное сложение.
Для того чтобы прибавить бит переноса, элементы вектора попарно переставляются местами, производится прибавление переноса, а затем возвращение элементов на свои места.
Эту операцию иллюстрирует листинг \ref{mint:add}.
\begin{listing}
	\caption{Сложение с переносом}
	\label{mint:add}
	\inputminted[breaklines, frame=single]{c}{figures/add.c}
\end{listing}

\subsection[Различия в версиях RVV]{Различия в версиях \rvv{}}
К сожалению, версия \rvv{} 0.7.1 гораздо менее доработана, нежели версия 1.0.
Одной из проблем версии 0.7.1, является отсутствие операции загрузки маски из памяти.
Для обхода этого ограничения используется команда \texttt{vmseq.vx}, она принимает на вход вектор и число, и если элемент вектора равен заданному числу, то бит в маске устанавливается в единицу.

Операция вычисления битов переноса при сложении в версии 0.7.1 сделана таким образом, что ей всегда требуется маска, даже если это первое вычисление, что требует создавать маску из нулей для корректной работы.

\subsection{Загрузка по невыровненному адресу}
Спецификация векторных расширений \riscv{} не определяет корректное поведение при загрузке данных из памяти по невыровненному адресу.
Так например в функции \texttt{XXH3\_accumulate}, два из трех указателей, принимаемых на вход, являются невыровненными.
К счастью, эту проблему легко обойти: достаточно загружать данные, как если бы вектор был из 8-битных элементов, а затем интерпретировать его как вектор нужной размерности, что демонстрирует листинг \ref{mint:unaligned}.
\begin{listing}
	\caption{Загрузка по невыровненному адресу}
	\label{mint:unaligned}
	\begin{minted}[breaklines, frame=single]{c}
vuint32m1_t key_vec = vreinterpret_v_u8m1_u32m1(vle8_v_u8m1((uint8_t*)(xsecret + VL * i), VL * 4));
	\end{minted}
\end{listing}
