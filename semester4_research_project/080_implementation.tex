% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}

Библиотека содержит в себе четыре алгоритма хеширования: \xxh{32}, \xxh{64}, \xxh{3}, \xxh{128}.
Первые два из них не поддаются оптимизации с помощью векторных операций, поэтому интерес представляют только последние два.
Внутри они используют функции \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc}.
Именно эти функции могут использовать векторные возможности процессора: в библиотеке уже имеется поддержка \textsc{SSE2, AVX512, NEON} и других.

Уже существующие реализации оперируют компонентами вектора размером в 64 бита, в терминологии \riscv{} это называется \textsc{SEW\footnote{Selected Element Width}}.
А длина вектора разнится от 128 бит до 512 бит, в терминологии \riscv{}~--- \textsc{VL\footnote{Vector Length}}.

По спецификации векторного расширения \riscv{}, минимальный \textsc{VL} равен 128 битам, так же должна присутствовать поддержка \textsc{SEW} равного 64 битам.
К сожалению, на момент написания данной работы в продаже можно было найти лишь устройства на чипе \textsc{Allwinner D1}, в котором отсутствует поддержка 64-битных элементов вектора, поэтому было решено использовать \textsc{SEW} в 32 бита из-за чего потребовалась некоторое количество ухищрений.

В качестве эталонной реализации был выбран для набора команд \textsc{SSE2}, т.к. целевой процессор имеет такой же \textsc{VL}, как и \textsc{SSE2}.

Одной из первых проблем стала операция умножения.
В алгоритме требуется перемножить 2 вектора, используя только младшие 32 бита каждого элемента, в результате чего получаются 64-битные числа.
В силу ограничений, использовалась следующая последовательность команд: сначала вычислялись

% Рассказать про то, что хотим умножить два 32-битных числа и расширить до 64 битов
% НО мы не умеем в SEW=64, поэтому танцы с бубном:
% умножаем отдельно low и high, двигаем high влево, мерджим high и low части

% Сложение, тварь такая, в смысле страдания с переносом
% узнаем где случается перенос, затем оставляем битики переноса только у 0 и 2 элемента,
% затем выполняем сложение без мыслей о переносе, затем меняем местами (0 и 1) и (2 и 3),
% после этого делаем сложение с переносом с нулевым вектором и только после этого возвращаем элементы на свои места

% RVV0.7.1 сука
% Нет команды загрузки масок, поэтому генерируем маски командой set if equal to
% Нет vmadc_vv, только vmadc_vvm, поэтому требуется создать пустую маску, БЛАГО хоть для этого есть инструкция
