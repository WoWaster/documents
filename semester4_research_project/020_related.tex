% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}
\subsection[Векторное расширение RISC-V]{Векторное расширение \riscv{}}
Векторное расширение \riscv{} находилось в разработке довольно долго, из-за чего производители чипов начали выпускать свои решения основываясь на недоработанной версии стандарта 0.7.1.
Один из таких чипов~--- \textsc{Allwinner D1}, получил большое распространение в недорогих одноплатных ПК, таких как \textsc{Sipeed Lichee RV} и \textsc{MangoPi MQ-Pro}.

Последней и официальной ратифицированной версией является версия 1.0, она поддерживается современными версия \textsc{LLVM} и \textsc{GCC}.
Версия 0.7.1 не была ратифицирована, и поддерживается лишь в специализированных версиях компиляторов, предназначенных для конкретных аппаратных платформ.
Насколько известно, единственным таким компилятором является компилятор от компании \textsc{Alibaba} на основе \textsc{GCC 10}\footnote{\url{https://occ.t-head.cn/community/download?id=4090445921563774976}}.

Для облегчения жизни программиста в компиляторах существуют так называемые intrinsic функции, которые позволяют использовать специфичные возможности процессора из высокоуровневых языков.
Спецификация \rvv{} определяет множество типов~(в смысле языка \textsc{C}), что порождает множество функций с практически идентичным названием.
Современные версии \textsc{LLVM} и \textsc{GCC} поддерживают перегрузку intrinsic функций, что делает код гораздо более читаемым~--- строго типы нужно указывать малому количеству операции, например загрузке и выгрузке векторов в память.
Сравнить читаемость кода можно на листинге \ref{mint:overload}.
К сожалению, в компиляторе от \textsc{Alibaba} данная возможность отсутствует.
\begin{listing}
	\caption{Сравнение перегруженных и не перегруженных функций}
	\label{mint:overload}
	\inputminted[breaklines, frame=single]{c}{figures/generic.c}
\end{listing}
Далее во всех листингах для компактности будут использоваться перегруженные версии intrinsic функций.

\subsection[Библиотека xxHash]{Библиотека \xxHash{}}
Библиотека содержит в себе четыре алгоритма хеширования: \xxh{32}, \xxh{64}, \xxh{3}, \xxh{128}.
Первые две хеш-функции были включены в состав библиотеки с первых версий, однако их алгоритм работы не позволяет использовать векторные возможности процессоров.
\xxh{3} и \xxh{128}, в свою очередь, разрабатывались с учетом векторных операций, поэтому они представляют интерес в данном исследовании.

\xxh{3} и \xxh{128} по сути используют один алгоритм, но возвращают 64- или 128-битные хеши соответственно.
Внутри они используют функции \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc}.
Первая из них получает на вход указатели на данные, секрет и аккумулятор, затем, особым образом изменив данные с помощью секрета, добавляет их в аккумулятор.
Вторая же, получая на вход секрет и аккумулятор после обработки большого блока данных, перемешивает аккумулятор для усиления хеширования.
