% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Эксперимент}

Измерения проводились на одноплатном компьютере \textsc{Sipeed Lichee RV 86} со следующими характеристиками:
\begin{itemize}
	\item Процессор \textsc{Allwinner D1} с частотой 1~ГГц;
	\item Оперативная память \textsc{DDR3} объемом 512~Мб с частотой 800~МГц;
	\item Операционная система \textsc{Debian Sid} с последними обновлениями на момент тестирования.
\end{itemize}

Для компиляции использовался компилятор от компании \textsc{Alibaba} с флагами \texttt{-O3} и \texttt{-march=rv64gcv0p7}.
Для выбора набора функций использовались флаги \texttt{-DXXH\_VECTOR=XXH\_SCALAR} и \texttt{-DXXH\_VECTOR=XXH\_RVV} соответственно.
Данные измерений были получены с помощью поставляемой вместе с библиотекой утилиты \texttt{xxhsum}.

\begin{table}[h]
	\def\arraystretch{1.1}  % Растяжение строк в таблицах
	\setlength\tabcolsep{0.2em}
	\centering
	\caption{Сравнение производительности хеш-функции \xxHash{3} на входных данных размером в 1000~Кб; числа приведены с относительной погрешностью 0.1\%}
	\begin{tabular}[C]{
			c
			*1{S
						[table-figures-uncertainty=2, separate-uncertainty=true, table-align-uncertainty=true,
							table-figures-integer=3, table-figures-decimal=2, round-precision=2,
							table-number-alignment=center]
				}
		}
		\toprule
		\multicolumn{1}{r}{Набор функций} & \multicolumn{1}{r}{Скорость работы, Мб/с} \\ \midrule
		Скалярный & 169.3 \\ \midrule
		Векторный & 116.0 \\
		\bottomrule
	\end{tabular}
	\label{tab:speed}
\end{table}

Результаты замеров приведены в таблице \ref{tab:speed}.
По ним можно сделать вывод, что в результате скорость работы алгоритма не только не увеличилась, более того, стала заметно меньше.
Можно предположить, что причиной этого являются способы обхода ограничений.
Функции \texttt{XXH3\_accumulate} и \texttt{XXH3\_scrambleAcc} являются ключевыми для вычисления хеша, а следовательно вызываются постоянно.
Использование 32-битных элементов требует предварительной загрузки большого количества масок и вспомогательных векторов в память, что затрачивает время перед основной обработкой данных.
Кроме того, операцию объединения векторов и операцию перестановки элементов в векторе можно считать сложными и длительными для исполнения, но именно они используются в большом объеме, что так же вносит значительный вклад в замедление алгоритма.

Встреченные трудности и результаты измерений позволяют сделать вывод о том, что использование 32-битных элементов векторов для обхода ограничений платформы приводит не только к сложным конструкциям в коде программы, но и не дает прироста производительности.
